# It is very important, that you set the TABSTOP to the correct tabsize of your editor,
# overwise the PRINT Command will probably make some errors
IF $(argc) = 4
ELSE
	ERROR	Falsche Parameteranzahl: Syntax aisc xxx.pa xxx.aisc outfile
ENDIF

DATA AISC { $(#FILE $(argv[2])) };
MOVETO $(AISC/PROJECT)

OPEN save $(argv[3])
# *********************************** IDENTS ***************
CREATE $(i)
CREATE $(replace)
IF $(MYTABSTOP)
	TABSTOP $(MYTABSTOP)
ELSE
	TABSTOP 8
ENDIF
TAB	0	0
TAB	1	8
TAB	2	16
TAB	3	24
TAB	4	32
TAB	5	40
TAB	6	48
TAB	7	56
TAB	8	64
TAB	9	72


OUT save
MOVETO $(DATA/.)

P /*********************************************************************/
P /* Created automatically from aisc.pa                                */
P /*********************************************************************/$n

P #ifndef NAMES_SERVER_INCLUDED
P #define NAMES_SERVER_INCLUDED$n

P typedef int 	hash;
P typedef char *aisc_string;
P typedef const char *aisc_cstring;
P #define _AISC_BYTESTRING
P typedef struct struct_bytestring {
P 	char	*data;
P	int	size;
P	} bytestring;

P $(INCLUDE_INCLUDES)

P /******************* SOME CONSTANTS *******************/
FOR $(CONST)
	P	#define $(CONST) $3$(VALUE) $6/* $(DOCU) $8*/
ENDFOR
	P	
P /******************* THE ENUMS *******************/
FOR $(ENUM)
	P $n$1/************** $(SDOCU|$(ENUM)) **************/
	P	typedef enum enum_$(ENUM) {
	FOR $({/VAR)
		IF $(VAL)
			P $2$(VAR)$3=$4 $(VAL),$\
		ELSE
			P $2$(VAR),$\
		ENDIF
		IF $(DOCU)
			P $6/* $(DOCU)$8*/
		ELSE
			P 
		ENDIF
	ENDFOR
	P	} $(ENUM);$n
ENDFOR
P /******************* THE KEYS *******************/
	P	typedef enum enum_t_key {
FOR $(STRUCT)
	IF $(JOINED)
	ELSEIF $(SKEY)
		P $1KEY_$(OBJECT_KEY)_$(SKEY) = $(SKEYC)*0x10000,
	ENDIF
ENDFOR
	P	$1KEY_MAX$n} t_key;
CREATE $(pre)
CREATE $(suf)

FOR $(STRUCT)
	P $n$1/************** $(SDOCU|$(STRUCT)) **************/
	CALL pre_structh
	P	typedef struct struct_$(STRUCT) {
	SET $(replace)
	CALL structh
	P } $(STRUCT);
ENDFOR
	P $n/************************** some privat structures **************/
FOR $(STRUCT.dll_public)
	CALL pre_structh
	P typedef struct struct_dllpublic_ext {
	SET $(replace) :dll_header=dllheader_ext:dll_public=dllpublic_ext
	CALL structh
	P $2struct struct_dllheader_ext $5*first;
	P }$1dllpublic_ext;
NEXT
	ERROR struct dll_public is missing
ENDFOR

FOR $(STRUCT.dll_header)
	CALL pre_structh
	P	typedef struct struct_dllheader_ext {
	SET $(replace) :dll_header=dllheader_ext:dll_public=dllpublic_ext
	CALL structh
	P	$2struct struct_dllheader_ext $5*previous, *next;
	P } dllheader_ext;
NEXT
	ERROR struct dll_header is missing
ENDFOR

P extern const char *aisc_server_error;

P #endif /* NAMES_SERVER_INCLUDED */
CLOSE save
EXIT


FUNCTION structh
	FOR $({/TYPE)
		SET $(pre)
		SET $(suf)
		IF $(TYPE) = dllh
			P $2dll_header$4mh;
			P $2struct struct_$(STRUCT)$4*previous, *next;
		ELSEIF $(REF) ~ %
		ELSE
			IF $(REF) ~ *
				SET $(pre) *
			ELSEIF $(REF) ~ v
				SET $(suf) [$(SIZE|NO SIZE DEFINED)]
			ENDIF
			IF $(REF) ~ d
				P $2dll_public$4p$(IDENT);
			ENDIF
			IF $(REF) ~ d,r,l,o
				SET $(pre) $(pre)*
			ENDIF
			IF $(REF) ~ f
				P $2struct struct_$(TYPE|NO TYPE FOUND$(replace)) $4$\
			ELSE
				P $2$(TYPE|NO TYPE FOUND$(replace)) $4$\
			ENDIF
			P $(pre)$(IDENT)$(suf)$\
			P ;$6/* $(DOCU| *** )$8*/
		ENDIF
	ENDFOR
RETURN

FUNCTION pre_structh
	FOR $({/TYPE)
		IF $(TYPE) = dllh
		ELSEIF $(REF) ~ %
		ELSE
			IF $(REF) ~ f
				P struct struct_$(TYPE|NO TYPE FOUND$(replace));
			ENDIF
		ENDIF
	ENDFOR
RETURN

