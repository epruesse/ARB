
IF $(argc) = 6
ELSE
        ERROR Wrong number of parameters[$(argc)]. Usage: aisc aisc_server.pa xxx.aisc externfile.aisc outfile import_proto
ENDIF

DATA AISC { $(#FILE $(argv[2])) }, EXTERN { $(#FILE $(argv[4])) };
DUMPDATA DUMP/aisc_server.pa__$(argv[2]).dump

OPEN save $(argv[3])
OPEN import $(argv[5])
# ************************* SET EXTERN FUNCTIONS ***************************
MOVETO $(EXTERN/.)
OUT save
FOR $(FUNCTION)
        CREATE $(extern_$(FUNCTION))
NEXT
        PP no extern Functions found
ENDFOR
# ***************************************************************************
MOVETO $(/AISC/PROJECT)
OUT import

P /* -----------------------------------------------------------------
P  * Created automagically from ../$(argv[2]) 
P  *                       and ../$(argv[4])
P  * using aisc-script '../AISC/aisc_server.pa'
P  * DO NOT EDIT THIS FILE!!!
P  * ----------------------------------------------------------------- */$n

OUT save
MOVETO $(DATA/.)
P /* ----------------------------------------------------------------- 
P  * Created automagically from ../$(argv[2])
P  *                       and ../$(argv[4])
P  * using aisc-script '../AISC/aisc_server.pa'
P  * DO NOT EDIT THIS FILE!!!
P  * ----------------------------------------------------------------- */$n
P $(#FILE C/aisc_server.h)$n

TABSTOP 8
TAB     0       0
TAB     1       8
TAB     2       16
TAB     3       24
TAB     4       32
TAB     5       40
TAB     6       48
TAB     7       56
TAB     8       64
TAB     9       72

CREATE $(v) = %
CREATE $(i) = 0
CREATE $(sp) = 0

# Tabellen initialisieren
FOR $(i) = 0 TO $(MAX_KEY)
        CREATE $(set_list[$(i)]) 0,
        CREATE $(get_list[$(i)]) 0,
        CREATE $(create_list[$(i)]) 0,
        CREATE $(find_list[$(i)]) 0,
        CREATE $(copy_list[$(i)]) 0,
ENDFOR
# Variablen deklarieren
CREATE $(add)
CREATE $(conds)
CREATE $(func)
CREATE $(access)
CREATE $(maintype)
CREATE $(conds_init)
CREATE $(index) #

P /************* MALLOC ******************/
FOR $(STRUCT)
        P $(STRUCT) *create_$(STRUCT)()$\
        IF $(extern_create_$(STRUCT))
                P ;
        ELSE
                P $n$1{$n$1$(STRUCT) *THIS$5= ($(STRUCT) *)calloc(sizeof($(STRUCT)), 1);
                P $1if(!THIS){ aisc_server_error = "Malloc error in create_$(STRUCT) !"; return 0;}
                SET $(maintype) $(STRUCT)
                SET $(access) THIS->
                GOSUB init_structure
                P $1return THIS; }$n
        ENDIF
ENDFOR

P /************* MOVE ******************/
FOR $(STRUCT)
        P int move_$(STRUCT)($(STRUCT) *sobj,$(STRUCT) *dobj)$\
        IF $(extern_move_$(STRUCT))
                P ;
        ELSE
                P { 
#int i = 0;
                SET $(maintype) $(STRUCT)
                GOSUB move_structure
                P $1return 0; }$n
        ENDIF
ENDFOR

P /************* COPY ******************/
FOR $(STRUCT)
        P $(STRUCT) *copy_$(STRUCT)($(STRUCT) *sobj)$\
        IF $(extern_copy_$(STRUCT))
                P ;
        ELSE
                P {
                P $1$(STRUCT) *dobj;
                P $1if(!sobj) return 0;
                P $1dobj$5= create_$(STRUCT)();
                P $1if(!dobj){ aisc_server_error = "Malloc error in copy_$(STRUCT) !"; return 0;}
                P $1trf_create((long)sobj,(long)dobj);
                P $1if (move_$(STRUCT)(sobj,dobj)) return 0;
                P $1return dobj; }$n
        ENDIF
ENDFOR


# /************* DELETE ******************/
IF $(extern_destroy_char)
        P void destroy_char(char *obj);
ELSE
        P void destroy_char(char *obj){ free(obj); }
ENDIF

FOR $(STRUCT)
        P void destroy_$(STRUCT)($(STRUCT) *obj)$\
        IF $(extern_destroy_$(STRUCT))
                P ;
        ELSE
                P {
                PUSH
                MOVETO $({/.)
                IF $(TYPE) = dllh
                        P $1if (obj->$(IDENT).parent) {
                        P $2aisc_unlink((dllheader_ext*)obj);
                        P $2if (aisc_server_error) return;
                        P $1}
                ENDIF
                POP
                SET $(maintype) $(STRUCT)
                SET $(access) obj->
                SET $(index) #
                GOSUB delete_structure
                P $1free(obj);
                P }$n
        ENDIF
ENDFOR

P /************** SAVE and LOAD **************/
P #ifdef AISC_SAVE_YES

CREATE $(TOKENSIZE) 1024

GOSUB save_token

CREATE $(prekey)
FOR $(STRUCT)
        P int save_$(STRUCT)($(STRUCT) *THIS, FILE *THIS_FD)$\
        IF $(extern_save_$(STRUCT))
                P ;
        ELSE
                P {$n
                SET $(maintype) $(STRUCT)
                SET $(access) THIS->
                GOSUB save_structure
                P $1return 0;
                P $1}$n
        ENDIF
ENDFOR


GOSUB load_token

FOR $(STRUCT)
        P int load_$(STRUCT)($(STRUCT) *THIS, FILE *THIS_FD)$\
        IF $(extern_load_$(STRUCT))
                P ;
        ELSE
                P {$n
                P $1char token[$(TOKENSIZE)+1];
                P $1while (!aisc_server_load_token(THIS_FD,token,$(TOKENSIZE))) {
                P $2if (*token == '}') { return 0;
                                # the } symbol is }else if
                SET $(maintype) $(STRUCT)
                SET $(access) THIS->
                GOSUB load_structure
                P $2}
                P $2else {
                P $3printf("Undefined Token %s\n",token);
                P $2} /* if token */
                P $1} /*while */
                P $1return 0;
                P $1}$n
        ENDIF
ENDFOR

P #endif


# /************* GET SET CREATE FIND COPY ******************/

FOR $(STRUCT)
        IF $(SKEY)
                P /************* FUNCTIONS $(STRUCT) *****************/$n
                IF $(JOINED)
                ELSE
                        FOR $(i) = 0 TO $(MAX_KEY)
                                SET $(set_list[$(i)]) $10,
                                SET $(get_list[$(i)]) $10,
                                SET $(create_list[$(i)]) $10,
                                SET $(find_list[$(i)]) $10,
                                SET $(copy_list[$(i)]) $10,
                        ENDFOR
                ENDIF
                SET $(add) 0
                SET $(conds) = #
                SET $(func) $(SKEY)_
                SET $(access) THIS->
                SET $(maintype) $(STRUCT)
                SET $(conds_init) 
                SET $(index) #
                GOSUB rec_structure
                IF $(JOIN_NEXT)
                ELSE
                        GOSUB print_tabs
                ENDIF
        ENDIF
ENDFOR

CLOSE save
CLOSE import
EXIT


FUNCTION rec_structure
                # Function name
        CREATE $(f) $(func)
                # relative key
        CREATE $(a) $(add)
                # conditions
        CREATE $(c) $(conds)
        CREATE $(ci) $(conds_init)
                # path
        CREATE $(ac) $(access)
        CREATE $(in) $(index)
        CREATE $(type)
        FOR $({/KEY)
                SET $(func) $(f)$(KEY)
                SET $(conds) $(c)

                IF $(TYPE) = dllh
                        IF $(get_list[$(+ 0+$(+ $(a)+$(KEYC)))]) ~ 0
                        ELSE
                                ERROR Number for 'get_$(func)PRED:$(KEYC)' already in use: '$(get_list[$(+ 0+$(+ $(a)+$(KEYC)))])'
                        ENDIF
                        SET $(get_list[$(+ 0+$(+ $(a)+$(KEYC)))])       get_$(func)PRED,
                        P $(maintype) $1*get_$(func)PRED($(maintype)$4 *THIS)$\
                        IF $(extern_get_$(func)PRED)
                                P ;
                        ELSE
                                P {$\
                                GOSUB create_access
                                GOSUB create_condition
                                P $3return ($(maintype) *)$(ac)previous;}
                        ENDIF
                        IF $(get_list[$(+ 1+$(+ $(a)+$(KEYC)))]) ~ 0
                        ELSE
                                ERROR Number for 'get_$(func)NEXT:$(KEYC)' already in use: '$(get_list[$(+ 1+$(+ $(a)+$(KEYC)))])'
                        ENDIF
                        SET $(get_list[$(+ 1+$(+ $(a)+$(KEYC)))])       get_$(func)NEXT,
                        P $(maintype) $1*get_$(func)NEXT($(maintype)$4 *THIS)$\
                        IF $(extern_get_$(func)NEXT)
                                P ;
                        ELSE
                                P {$\
                                GOSUB create_access
                                GOSUB create_condition
                                P $3return ($(maintype) *)$(ac)next;}
                        ENDIF
                        PUSH
                        SET $(add) $(+ 2+$(+ $(a)+$(KEYC)))
                        SET $(access) $(ac)$(IDENT).
                        SET $(conds_init) $(ci)
                        MOVETO $(/AISC/DATA/STRUCT.dll_header)
                        GOSUB rec_structure
                        POP
                        CONTINUE
                ENDIF

                SET $(index) $(in)
                SET $(access) $(ac)$(IDENT)
                SET $(conds_init) $(ci)

                IF $(REF) ~ *
                        SET $(conds) $(conds)&&($(access))
                        SET $(index) $(SIZE:THIS->=$(ac))
                        IF $(REF) ~ o,d,l,r
                                SET $(type) $(TYPE) *
                        ELSE
                                SET $(type) $(TYPE)
                        ENDIF
                        SET $(conds_init) $(conds_init)$3if(!$(access)) $(access) = ($(type)*)calloc(sizeof($(type)),$(index));$n
                        SET $(access) $(access)[index]
                ELSEIF $(REF) ~ v
                        SET $(index) $(SIZE:THIS->=$(ac))
                        SET $(access) $(access)[index]
                ENDIF
                IF $(REF) ~ s
                        IF $(REF) ~ o,l,r
                                SET $(conds) $(conds)&&($(access))
                                SET $(conds_init) $(conds_init)$3if(!$(access)) $(access) = create_$(TYPE)();$n
                                SET $(access) $(access)->
                        ELSEIF $(REF) ~ i
                                SET $(access) $(access).
                        ENDIF
                        PUSH
                        SET $(add) $(+ $(a)+$(KEYC))
                        MOVETO $(/AISC/DATA/STRUCT.$(TYPE))
                        CALL rec_structure
                        POP
                        CONTINUE
                ENDIF
                IF $(REF) ~ o,d
        # ********************************** CREATE FUNCTIONS ****************************
                        IF $(ACC) !~ c
                        ELSE
                                IF $(create_list[$(+ $(a)+$(KEYC))]) ~ 0
                                ELSE
                                        ERROR Number for 'create_$(func):$(KEYC)' already in use: '$(create_list[$(+ $(a)+$(KEYC))])'
                                ENDIF
                                SET $(create_list[$(+ $(a)+$(KEYC))])   create_$(func),
                                P $(TYPE) $1*create_$(func)($(maintype) *THIS)$\
                                IF $(extern_create_$(func))
                                        P ;
                                ELSE
                                        P {$\
                                        P $(TYPE) *obj;
                                        CALL create_index y,0
                                        CALL create_condition
                                        P $3obj = create_$(TYPE)();
                                        P $3if(!obj) { aisc_server_error = "MALLOC ERROR in create_$(func)"; return 0; }
                                        P $3aisc_make_sets((long *)obj);
                                        P $3if(aisc_server_error) {
                                        P $4destroy_$(TYPE)(obj);
                                        P $4return 0;
                                        P $3}
                                        IF $(REF) ~ d
                                                P $3aisc_server_error = aisc_link((dllpublic_ext*)&($(ac)p$(IDENT)),(dllheader_ext*)obj);
                                        ELSE
                                                P $3if ($(access)) destroy_$(TYPE)($(access));
                                                P $3$(access) = obj;
                                        ENDIF
                                        P $3return obj;}
                                ENDIF
        # ********************************** COPY FUNCTIONS ****************************
                                IF $(copy_list[$(+ $(a)+$(KEYC))]) ~ 0
                                ELSE
                                        ERROR Number for 'copy_$(func):$(KEYC)' already in use: '$(copy_list[$(+ $(a)+$(KEYC))])'
                                ENDIF
                                SET $(copy_list[$(+ $(a)+$(KEYC))])     copy_$(func),
                                P $(TYPE) $1*copy_$(func)($(maintype)$4 *THIS)$\
                                IF $(extern_copy_$(func))
                                        P ;
                                ELSE
                                        P {$\
                                        P $(TYPE) *obj;
                                        CALL create_index y,0
                                        CALL create_condition
                                        P $3trf_begin();
                                        P $3obj$4= copy_$(TYPE)($(access));
                                        P $3trf_commit(0);
                                        P $3if(!obj) { aisc_server_error = "MALLOC ERROR in create_$(func)"; return 0; }
                                        P $3aisc_make_sets((long *)obj);
                                        P $3if(aisc_server_error) {
                                        P $4destroy_$(TYPE)(obj);
                                        P $4return 0;
                                        P $3}
                                        IF $(REF) ~ d
                                                P $3aisc_server_error = aisc_link((dllpublic_ext*)&($(ac)p$(IDENT)),(dllheader_ext*)obj);
                                        ELSE
                                                P $3if ($(access)) destroy_$(TYPE)($(access));
                                                P $3$(access) = obj;
                                        ENDIF
                                        P $3return obj;}
                                ENDIF
                        ENDIF
        # ********************************** FIND FUNCTIONS ****************************
                        IF $(ACC) !~ f
                        ELSEIF $(REF) ~ d
                                IF $(find_list[$(+ $(a)+$(KEYC))]) ~ 0
                                ELSE
                                        ERROR Number for 'find_$(func):$(KEYC)' already in use: '$(find_list[$(+ $(a)+$(KEYC))])'
                                ENDIF
                                SET $(find_list[$(+ $(a)+$(KEYC))])     find_$(func),
                                P $(TYPE) $1*find_$(func)($(maintype)$4 *THIS,char *key)$\
                                IF $(extern_find_$(func))
                                        P ;
                                ELSE
                                        P {$\
                                        P $(TYPE) *obj;$\
                                        GOSUB create_access
                                        GOSUB create_condition
                                        P $3obj = ($(TYPE)*)aisc_read_hash((struct aisc_hash_node**)$(ac)p$(IDENT).hash,key);
                                        P $3return obj;}
                                ENDIF
                        ENDIF
        # ********************************** CNT FUNCTION ****************************
                        IF $(REF) ~ d
                                IF $(get_list[$(+ 1 +$(+ $(a)+$(KEYC)))]) ~ 0
                                ELSE
                                        ERROR Number for get_$(func)_CNT:$(KEYC) already in use: '$(get_list[$(+ 1 +$(+ $(a)+$(KEYC)))])'
                                ENDIF
                                SET $(get_list[$(+ 1 +$(+ $(a)+$(KEYC)))])      get_$(func)_CNT,
                                IF $(extern_get_$(func)_CNT)
        #                               P ;
                                ELSE
                                        P int $1get_$(func)_CNT($(maintype) *THIS)$\
                                        P {$\
                                        GOSUB create_access
                                        GOSUB create_condition
                                        P $3return $(ac)p$(IDENT).cnt;}
                                ENDIF
                        ENDIF
        #***************** SET FUNCTIONS *********************
                ELSE
                        IF $(set_list[$(+ $(a)+$(KEYC))]) ~ 0
                        ELSE
                                ERROR Number for set $(KEY):$(KEYC) already in use: '$(set_list[$(+ $(a)+$(KEYC))])'
                        ENDIF

                        IF $(ACC) !~ w
                        ELSEIF $(REF) ~ $(v)
                                IF $(extern_$(IDENT))
                                        SET $(set_list[$(+ $(a)+$(KEYC))])      $(IDENT),
                                ELSE
                                        SET $(set_list[$(+ $(a)+$(KEYC))])      $(IDENT),
                                        OUT import      # Generate Prototypes for import
                                        P extern int $1$(IDENT)($(maintype)*, $(TYPE:bytestring=bytestring *)); /* (1) */
                                        OUT save
                                ENDIF
                        ELSE
                                SET $(set_list[$(+ $(a)+$(KEYC))])      set_$(func),
                                IF $(REF) ~ o,l,r
                                        P void $1set_$(func)($(maintype)$4 *THIS,$(TYPE) *x)$\
                                ELSEIF $(REF) ~ t,e
                                        P void $1set_$(func)($(maintype)$4 *THIS,$(TYPE:bytestring=bytestring *) x)$\
                                ELSE
                                        ERROR UNKNOWN REF '$(REF|)' in $(STRUCT).$(TYPE)
                                ENDIF
                                IF $(extern_set_$(func))
                                        P ;
                                ELSE
                                        P {
                                        GOSUB create_index n,n
                                        GOSUB create_vterms
                                #       GOSUB create_access_noval
                                        GOSUB create_condition
                                        IF $(TYPE) = aisc_string
                                                P $3if($(access)) free($(access));
                                                P $3$(access) = x;}
                                        ELSEIF $(TYPE) = bytestring
                                                P $3if($(access).data) free($(access).data);
                                                P $3if(x){
                                                P $4$(access).data$6= x->data;
                                                P $4$(access).size$6= x->size;
                                                P $3}
                                                P $3else {
                                                P $4$(access).data$6= 0;
                                                P $4$(access).size$6= 0;
                                                P $3}
                                                P $2}
                                        ELSE
                                                IF $(REF) ~ o
                                                        P $3if ($(access))
                                                        P $4destroy_$(TYPE)($(access));
                                                ENDIF
                                                P $3$(access)$5= x;}
                                        ENDIF
                                ENDIF
                        ENDIF
                ENDIF
        #**************** GET FUNCTIONS *********************
                IF $(get_list[$(+ $(a)+$(KEYC))]) ~ 0
                ELSE
                        ERROR Number for get $(KEY):$(KEYC) already in use: '$(get_list[$(+ $(a)+$(KEYC))])'
                ENDIF
                IF $(ACC) !~ r
                ELSEIF $(REF) ~ $(v)
                        IF $(extern_$(IDENT))
                                SET $(get_list[$(+ $(a)+$(KEYC))])      $(IDENT),
                        ELSE
                                IF $(IDENT) = aisc_get_keystring
                                        SET $(get_list[$(+ $(a)+$(KEYC))])      (const char*(*)(int*))$(IDENT),/* special cast for aisc_get_keystring */
                                ELSE
                                        SET $(get_list[$(+ $(a)+$(KEYC))])      ($(TYPE:bytestring=bytestring *)(*)($(maintype)*))$(IDENT),/* explicit cast to overloaded function type before casting to void */
                                ENDIF
                                OUT import      # Generate Prototypes for import
                                P extern $(TYPE:bytestring=bytestring *)  $2$(IDENT)($(maintype)*); /* (2) */
                                OUT save
                        ENDIF

                ELSE
                        SET $(get_list[$(+ $(a)+$(KEYC))])      get_$(func),
                        IF $(extern_get_$(func))
                        ELSE
                                IF $(REF) ~ o,l,r,d
                                        P $(TYPE) $1*get_$(func)$\
                                ELSEIF $(REF) ~ e,t
                                        P $(TYPE:bytestring=bytestring *) $1get_$(func)$\
                                ELSE
                                        ERROR UNKNOWN REF '$(REF|)' in $(STRUCT).$(TYPE)
                                ENDIF
                                P ($(maintype)$4 *THIS)$\
                                P {$\
                                GOSUB create_index y,0
                                GOSUB create_condition
                                IF $(TYPE) = bytestring
                                        P $3return &($(access));}
                                ELSE
                                        P $3return $(access);}
                                ENDIF
                        ENDIF
                ENDIF
        ENDFOR
RETURN

# ***************************** free a structure *******************************
FUNCTION delete_structure
        CREATE $(ac) $(access)
        CREATE $(end)
        CREATE $(start)
        CREATE $(in) $(index)
        FOR $({/TYPE)

                SET $(index) $(in)
                SET $(access) $(ac)$(IDENT)
                SET $(end)
                IF $(DESTROY)
                        P $1$(DESTROY:THIS=obj);
                ELSEIF $(REF) ~ $(v)
                                #virtuell function
                ELSE
                        IF $(REF) ~ *,v
                                SET $(index) $(SIZE:THIS->=$(ac))
                                IF $(REF) ~ *
                                        P $1if($(access)) $\
                                        SET $(end) $1}free($(access));}$n
                                ELSE
                                        SET $(end) $1}}$n
                                ENDIF
                                P $1{int index;
                                P $1for (index = 0; index < $(index); index++) {
                                SET $(access) $(access)[index]
                        ENDIF
                        IF $(TYPE) = dllh
                                SET $(access) $(access).
                                PUSH
                                MOVETO $(/AISC/DATA/STRUCT.dll_header)
                                GOSUB delete_structure
                                POP
                        ELSEIF $(REF) ~ s
                                IF $(REF) ~ o,d,i
                                        PUSH
                                        IF $(REF) ~ i
                                                CREATE $(access) $(access).
                                        ELSE
                                                P $1if($(access)) {
                                                CREATE $(access) $(access)->
                                        ENDIF
                                        MOVETO $(/AISC/DATA/STRUCT.$(TYPE))
                                        GOSUB delete_structure
                                        POP
                                        IF $(REF) !~ i
                                                P $1free$2((char *)$(access));}
                                        ENDIF
                                ENDIF
                        ELSEIF $(REF) ~ d
                                P $1while ($(access)) {
                                P $2destroy_$(TYPE)($(access));
                                P $2if (aisc_server_error)$5return;}
                        ELSEIF $(REF) ~ o
                                P $1if ($(access))$4destroy_$(TYPE)($(access));
                                P $1if (aisc_server_error)$5return;
                        ELSEIF $(REF) ~ t,e
                                IF $(TYPE) = aisc_string
                                        P $1if($(access))$4free($(access));
                                ELSEIF $(TYPE) = bytestring
                                        P $3if($(access).data) free($(access).data);
                                ENDIF
                        ELSEIF $(REF) ~ l
                        ELSE
                                ERROR UNKNOWN REF '$(REF|)' in $(STRUCT).$(TYPE)
                        ENDIF
                        P $(end)$\
                ENDIF
        ENDFOR
RETURN

# ***************************** save a structure *******************************
FUNCTION save_structure
        CREATE $(ac) $(access)
        CREATE $(end)
        CREATE $(start)
        CREATE $(in) $(index)
        CREATE $(prekey) $(prekey)
        FOR $({/TYPE)

                SET $(index) $(in)
                SET $(access) $(ac)$(IDENT)
                SET $(end)
                IF $(REF) ~ $(v)
                                #virtuell function
                ELSEIF $(SAVE)
                        IF $(REF) ~ *,v
                                SET $(index) $(SIZE:THIS->=$(ac))
                                IF $(REF) ~ *
                                        P $1if($(access)) $\
                                        SET $(end) $1}}$n
                                ELSE
                                        SET $(end) $1}}$n
                                ENDIF
                                P $1{int index;
                                P $1for (index = 0; index < $(index); index++) {
                                SET $(access) $(access)[index]
                        ENDIF
                        IF $(TYPE) = dllh
                                SET $(access) $(access).
                                PUSH
                                CREATE $(prekey) $(prekey)$(KEY)
                                MOVETO $(/AISC/DATA/STRUCT.dll_header)
                                GOSUB save_structure
                                POP
                        ELSEIF $(REF) ~ s               #sub structure
                                IF $(REF) ~ o,d,i
                                        PUSH
                                        IF $(REF) ~ i
                                                CREATE $(access) $(access).
                                        ELSE
                                                P $1if($(access)) {
                                                CREATE $(access) $(access)->
                                        ENDIF
                                        CREATE $(prekey) $(prekey)$(KEY|NOKEYDEFINED)
                                        MOVETO $(/AISC/DATA/STRUCT.$(TYPE))
                                        GOSUB save_structure
                                        POP
                                        P $1};
                                ENDIF
                        ELSEIF $(REF) ~ d
                                P $1{$(TYPE) *cobj;
                                P $2for(cobj = $(access);cobj;cobj=cobj->next) {
                                P $3int error;
                                P $3fprintf(THIS_FD,"$(prekey)$(KEY|NOKEYDEFINED){ ");
                                P $3error = save_$(TYPE)(cobj,THIS_FD);
                                P $3if (error) return error;
                                P $3fprintf(THIS_FD,"}\n");
                                P $1}};
                        ELSEIF $(REF) ~ o
                                P $1fprintf(THIS_FD,"$(prekey)$(KEY) {\n");
                                P $1{ int error = save_$TYPE($(access),THIS_FD);
                                P $1if (error) return error; }
                                P $1fprintf(THIS_FD,"}\n");
                        ELSEIF $(REF) ~ t,e
                                IF $(TYPE) = aisc_string
                                        P $1if ($(access)){
                                        P $2fprintf(THIS_FD,"$(prekey)$(KEY|NOKEYDEFINED) ");
                                        P $2aisc_server_save_token(THIS_FD,$(access),$(TOKENSIZE));}
                                ELSEIF $(TYPE) = int,long,char
                                        P $1fprintf(THIS_FD,"$(prekey)$(KEY|NOKEYDEFINED) %i\n",$(access));
                                ELSEIF $(TYPE) = float,double
                                        P $1fprintf(THIS_FD,"$(prekey)$(KEY|NOKEYDEFINED) %f\n",$(access));
                                ELSE
                                        ERROR CANNOT SAVE TYPE '$(TYPE)'
                                ENDIF
                        ELSEIF $(REF) ~ l
                                P $1fprintf(THIS_FD,"$(prekey)$(KEY|NOKEYDEFINED) %i",$(access));
                        ELSE
                                ERROR UNKNOWN REF '$(REF|)' in $(STRUCT).$(TYPE)
                        ENDIF
                        P $(end)$\
                ENDIF
        ENDFOR
RETURN

# ***************************** load a structure *******************************
FUNCTION save_token
        P int aisc_server_save_token(FILE *fd,char *buffer, int maxsize){
        P $1char *p;
        P $1int c;
        P $1putc('{',fd);
        P $1p = buffer;
        P $1while(maxsize-->0){
        P $1    c = *(p++);if (!c) break;
        P $1    if (c=='}' || c == '\\') putc('\\',fd);
        P $1    putc(c,fd);
        P $1}
        P $1putc('}',fd);
        P $1return 0;
        P $1}
RETURN


FUNCTION load_token
        P int aisc_server_load_token(FILE *fd,char *buffer, int maxsize)
        P $1{
        P $1char *p;
        P $1int c;
        P $1int in_brackets = 0;
        P $1p = buffer;
        P $1while(maxsize-->0){
        P $2c = getc(fd);
        P $2if (c==EOF) { *p=0; return EOF;}
        P $2else if (in_brackets) {
        P $2    if (c=='\\') { c = getc(fd); *(p++) = c; continue; }
        P $2    if (c!='}') *(p++) = c;else {*p=0;return 0;}
        P $2}
        P $2else if (c=='{') { 
        P $3if (p!=buffer) { *(p++) = '{'; *p=0; return 0; }
        P $3else in_brackets = 1; 
        P $2}
        P $2else if (c==' ') { if (p!=buffer) { *p=0; return 0; } }
        P $2else if (c=='\n') { if (p!=buffer) { *p=0; return 0; } }
        P $2else if (c=='}') { *(p++) = '}'; *p=0; return 0; }
        P $2else *(p++) = c;
        P $1}
        P $1*p = 0; return EOF; /* read error maxsize reached */
        P $1}
RETURN

FUNCTION load_structure
        CREATE $(ac) $(access)
        CREATE $(end)
        CREATE $(start)
        CREATE $(in) $(index)
        CREATE $(prekey) $(prekey)
        FOR $({/TYPE)

                SET $(index) $(in)
                SET $(access) $(ac)$(IDENT)
                SET $(end)
                IF $(REF) ~ $(v)
                                #virtuell function
                ELSEIF $(SAVE)
                        IF $(REF) ~ *,v
                                SET $(index) $(SIZE:THIS->=$(ac))
                                IF $(REF) ~ *
                                        P $1if($(access)) $\
                                        SET $(end) $1}}$n
                                ELSE
                                        SET $(end) $1}}$n
                                ENDIF
                                P $1{int index;
                                P $1for (index = 0; index < $(index); index++) {
                                SET $(access) $(access)[index]
                        ENDIF
                        IF $(TYPE) = dllh
                                SET $(access) $(access).
                                PUSH
                                CREATE $(prekey) $(prekey)$(KEY)
                                MOVETO $(/AISC/DATA/STRUCT.dll_header)
                                GOSUB load_structure
                                POP
                        ELSEIF $(REF) ~ s               #sub structure
                                IF $(REF) ~ o,d,i
                                        PUSH
                                        IF $(REF) ~ i
                                                CREATE $(access) $(access).
                                        ELSE
                                                P $1if($(access)) {
                                                CREATE $(access) $(access)->
                                        ENDIF
                                        CREATE $(prekey) $(prekey)$(KEY|NOKEYDEFINED)
                                        MOVETO $(/AISC/DATA/STRUCT.$(TYPE))
                                        GOSUB load_structure
                                        POP
                                        P $1};
                                ENDIF
                        ELSEIF $(REF) ~ d
                                P $2}
                                P $2else if (!strcmp("$(prekey)$(KEY|NOKEYDEFINED){",token)) {
                                P $3$(TYPE) *cobj = create_$(TYPE)();
                                P $3{
                                P $4int error = load_$(TYPE)(cobj,THIS_FD);
                                P $4if(error) return error; 
                                P $3}
                                P $3aisc_link((dllpublic_ext*)&($(ac)p$(IDENT)),(dllheader_ext*)cobj);
                        ELSEIF $(REF) ~ o
                                P $1fprintf(THIS_FD,"$(prekey)$(KEY) {\n");
                                P $1{ int error = save_$TYPE($(access),THIS_FD);
                                P $1if (error) return error; }
                                P $1fprintf(THIS_FD,"}\n");
                        ELSEIF $(REF) ~ t,e
                                P $2}
                                P $2else if(!strcmp("$(prekey)$(KEY|NOKEYDEFINED)",token)) {
                                P $3if (aisc_server_load_token(THIS_FD,token,$(TOKENSIZE))) return 1;
                                IF $(TYPE) = aisc_string
                                        P $3$(access) = strdup(token);
                                ELSEIF $(TYPE) = int,long,char
                                        P $3$(access) = atoi(token);
                                ELSEIF $(TYPE) = float,double
                                        P $3$(access) = atof(token);
                                ELSE
                                        ERROR CANNOT SAVE TYPE '$(TYPE)'
                                ENDIF
                        ELSEIF $(REF) ~ l
                                P I cannot load links yet
                        ELSE
                                ERROR UNKNOWN REF '$(REF|)' in $(STRUCT).$(TYPE)
                        ENDIF
                        P $(end)$\
                ENDIF
        ENDFOR
RETURN



# ***************************** init a structure *******************************
FUNCTION init_structure
        CREATE $(ac) $(access)
        CREATE $(end)
        CREATE $(my_key)
        CREATE $(index)
        FOR $({/TYPE)

                SET $(index)
                SET $(access) $(ac)$(IDENT)
                SET $(end)
                IF $(REF) ~ $(v)
                ELSE
                        IF $(REF) ~ v
                                SET $(index) $(SIZE:THIS->=$(ac))
                                SET $(end) $1}}$n
                                P $1{int index; for (index = 0; index < $(index); index++) {
                                SET $(access) $(access)[index]
                        ENDIF
                        IF $(TYPE) = dllh
                                P $1$(access).key$5= KEY_$(OBJECT_KEY)_$(SKEY|COMMON);
                                SET $(access) $(access).
                                PUSH
                                MOVETO $(/AISC/DATA/STRUCT.dll_header)
                                GOSUB init_structure
                                POP
                        ELSEIF $(REF) ~ d
                                P $1$(ac)p$(IDENT).parent$5= (dllheader_ext *)THIS;
                                PUSH
                                        MOVETO $(/AISC/DATA/STRUCT.$(TYPE))
                                        SET $(my_key) $(SKEY|SKEY_missing)
                                POP
                                P $1$(ac)p$(IDENT).key$5= KEY_$(OBJECT_KEY)_$(my_key);
                        ELSEIF $(REF) ~ s
                                IF $(REF) ~ i
                                        PUSH
                                        CREATE $(access) $(access).
                                        MOVETO $(/AISC/DATA/STRUCT.$(TYPE))
                                        GOSUB init_structure
                                POP
                                ENDIF
                        ELSEIF $(REF) ~ t,e,l
                                IF $(IDENT) = key
                                        IF $(SKEY) !~ COMMON
                                                P $1$(access)$5= KEY_$(OBJECT_KEY)_$(SKEY|COMMON);
                                        ENDIF
                                ELSEIF $(INIT)
                                        IF $(TYPE) = aisc_string
                                                P $1$(access)$5= (char *)strdup($(INIT));
                                        ELSE
                                                P $1$(access)$5= $(INIT);
                                        ENDIF
                                ENDIF
                        ELSE
                                PP UNKNOWN REF '$(REF|)' in $(STRUCT).$(TYPE)

                        ENDIF
                        P $(end)$\
                ENDIF
        ENDFOR
RETURN

# ***************************** move a structure *******************************
FUNCTION move_structure
        CREATE $(access)
        CREATE $(end)
        CREATE $(my_key)
        CREATE $(index)
        FOR $({/TYPE)
                SET $(index)
                SET $(access) $(IDENT)
                SET $(end)
                IF $(REF) ~ $(v)
                ELSEIF $(IDENT) = key
                ELSE
                        IF $(REF) ~ *,v
                                IF $(SIZE)
                                        SET $(index) $(SIZE:THIS->=sobj->)
                                ELSE
                                        ERROR Missing SIZE in STRUCT $(STRUCT) ident $(IDENT)
                                ENDIF
                                IF $(REF) ~ *
                                        P $1if(dobj->$(access))$4$\
                                ENDIF
                                SET $(end) $1}}$n
                                P $1{int index;
                                P $1for (index = 0; index < $(index); index++) {
                                SET $(access) $(access)[index]
                        ENDIF
                        IF $(TYPE) = dllh
                                P $1move_dll_header(&(sobj->$(access)),&(dobj->$(access)));
                        ELSEIF $(REF) ~ l,r
                                P $1dobj->$(access)$4= sobj->$(access);
                                P $1trf_link((long)sobj->$(access), (long*)&dobj->$(access));
                        ELSEIF $(REF) ~ o
                                P $1dobj->$(access)$4= copy_$(TYPE)(sobj->$(access));
                        ELSEIF $(REF) ~ d
                                P $1{$(TYPE) *cobj,*d2obj;
                                P $1for(cobj = sobj->$(access);cobj;cobj=cobj->next) {
                                P $2d2obj$4= copy_$(TYPE)(cobj);
                                P $2if (!d2obj) return 1;
                                P $2aisc_server_error = aisc_link((dllpublic_ext*)&(dobj->p$(access)),(dllheader_ext*)d2obj);
                                P $2if(aisc_server_error)return 1;
                                P $1}};
                        ELSEIF $(REF) ~ s
                                IF $(REF) ~ i
                                        P $1if (move_$(TYPE)(&(sobj->$(access)),&(dobj->$(access)))) return 1;
                                ENDIF
                        ELSEIF $(REF) ~ t,e
                                IF $(TYPE) = aisc_string
                                        P $1if (sobj->$(access)) {
                                        P $2dobj->$(access)$4= strdup(sobj->$(access));}
                                ELSEIF $(TYPE) = bytestring
                                        P $1if(sobj->$(access).data) {
                                        P $2dobj->$(access).data = (char *)malloc(sobj->$(access).size);
                                        P $2memcpy(dobj->$(access).data, sobj->$(access).data, sobj->$(access).size);
                                        P $2dobj->$(access).size=sobj->$(access).size;
                                        P $2}
                                ELSE
                                        P $1dobj->$(access)$4= sobj->$(access);
                                ENDIF
                        ELSE
                                PP UNKNOWN REF '$(REF|)' in $(STRUCT).$(TYPE)
                        ENDIF
                        P $(end)$\
                ENDIF
        ENDFOR
RETURN

# ***************************** create the condition *******************************
FUNCTION create_condition
        IF $(COND:==)
                P $n$3if(!($(COND:THISgrep ->=$(ac)))){
                P $4aisc_server_error = "$(CONDE|Condition error in $(f)$(KEY))";
                P $4return 0;}
        ENDIF
RETURN
# ***************************** create vterms *******************************
FUNCTION create_vterms
        P $(conds_init)$\
RETURN

FUNCTION create_index flag,return
        IF $(index) !~ #
                P $3int index;
        ENDIF
        IF $(flag) = y
                IF $(conds) ~ &
                                P $3if(!($(conds:#&&=))){$\
                                P return $(INIT|0); }
                ENDIF
        ENDIF
        IF $(index) !~ #
                P $3index = aisc_talking_get_index(0,$(index));
                IF $(return) = n
                        P $3if (aisc_server_error) return ;
                ELSE
                        P $3if (aisc_server_error) return $(return);
                ENDIF
        ENDIF
RETURN

# ***************************** create access including testing *******************************
FUNCTION create_access
        CREATE $(c) $(conds)
        IF $(c) ~ &
                        P $3if(!($(c:#&&=))){$\
                        P return $(INIT|0); }
        ENDIF
RETURN


# ***************************** create  testing *******************************
FUNCTION create_access_noval
        CREATE $(c) $(conds)
                                IF $(c:&=-) = $(c)
                                        # Keine Abfragen noetig
                                ELSE
                                        P $3if(!($(c:#&&=))){ return ; }
                                ENDIF
RETURN

# ***************************** create  output *******************************
FUNCTION print_tabs
                P #define static
                P static void * aisc_talking_functions_set_$(STRUCT)[] = {
                FOR $(i) = 0 TO $(MAX_KEY)
                        P $1(void *)$(set_list[$(i)])/*$(i)*/
                ENDFOR
                P $10$n};$n
                P static void *aisc_talking_functions_get_$(STRUCT)[] = {
                FOR $(i) = 0 TO $(MAX_KEY)
                        P $1(void *)$(get_list[$(i)])
                ENDFOR
                P $10$n};$n
                P static void * aisc_talking_functions_create_$(STRUCT)[]= {
                FOR $(i) = 0 TO $(MAX_KEY)
                        P $1(void *)$(create_list[$(i)])
                ENDFOR
                P $10$n};$n
                P static void * aisc_talking_functions_find_$(STRUCT)[] = {
                FOR $(i) = 0 TO $(MAX_KEY)
                        P $1(void *)$(find_list[$(i)])
                ENDFOR
                P $10$n};$n
                P static void * aisc_talking_functions_copy_$(STRUCT)[] = {
                FOR $(i) = 0 TO $(MAX_KEY)
                        P $1(void *)$(copy_list[$(i)])
                ENDFOR
                P $10$n};$n
RETURN

