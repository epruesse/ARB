IF $(argc) != 4
    ERROR Wrong number of parameters[$(argc)]. Usage: aisc aisc_com.pa xxx.aisc outfile
ENDIF

DATA AISC { $(#FILE $(argv[2])) };
DUMPDATA DUMP/aisc_com.pa__$(argv[2]).dump

OPEN save $(argv[3])
MOVETO $(AISC/PROJECT)

OUT save
MOVETO $(DATA/.)

P /* -----------------------------------------------------------------
P  * Created automagically from ../$(argv[2])
P  * using aisc-script '../AISC/aisc_com.pa'
P  * DO NOT EDIT THIS FILE!!!
P  * ----------------------------------------------------------------- */$n

P #ifndef _LIMITS_H
P #include <limits.h>
P #endif
P #ifndef AISC_GLOBAL_H
P #include <aisc_global.h>
P #endif

P #ifndef AISC_MAX_OBJECT
P # define AISC_MAX_OBJECT         $(MAX_OBJECT)
P # define AISC_MAX_ATTR           $(MAX_KEY)
P # define MAX_AISC_SET_GET        $(MAX_PAR_CNT)
P # define AISC_MAX_STRING_LEN     $(MAX_STRING_LEN)
P # define AISC_MESSAGE_BUFFER_LEN ((AISC_MAX_STRING_LEN/4+3)*($(MAX_PAR_CNT)+2))
P # define AISC_MAGIC_NUMBER       $(MAGIC_NUMBER)00
--
P struct aisc_com;
--
P const int AISC_GET $|= AISC_MAGIC_NUMBER+0;
P const int AISC_SET $|= AISC_MAGIC_NUMBER+1;
P const int AISC_NSET $|= AISC_MAGIC_NUMBER+2;
P const int AISC_CREATE $|= AISC_MAGIC_NUMBER+3;
P const int AISC_FIND $|= AISC_MAGIC_NUMBER+4;
P const int AISC_COPY $|= AISC_MAGIC_NUMBER+5;
P const int AISC_DELETE $|= AISC_MAGIC_NUMBER+6;
P const int AISC_INIT $|= AISC_MAGIC_NUMBER+7;
P const int AISC_DEBUG_INFO $|= AISC_MAGIC_NUMBER+8;
--
P const int AISC_CCOM_OK $|= AISC_MAGIC_NUMBER+0;
P const int AISC_CCOM_ERROR $|= AISC_MAGIC_NUMBER+1;
P const int AISC_CCOM_MESSAGE $|= AISC_MAGIC_NUMBER+2;
--
P #endif
--
FOR $(ENUM)
    IF $(SKEY)
        CREATE $(my_attribute[$(ENUM)]) $(OBJECT_KEY)_ATTR_$(SKEY)
    ENDIF
ENDFOR
--
P #define $(OBJECT_KEY)_ATTR_INT(a,b) $|(((a)+(b))|0x1000000)
FOR $(ENUM)
    IF $(SKEY)
        P #define $(OBJECT_KEY)_ATTR_$(SKEY)(a,b) $|(((a)+(b))|0x1000000)
    ENDIF
ENDFOR
P #define $(OBJECT_KEY)_ATTR_DOUBLE(a,b) $|(((a)+(b))|0x2000000)
P #define $(OBJECT_KEY)_ATTR_STRING(a,b) $|(((a)+(b))|0x3000000)
CREATE $(my_attribute[char]) $(OBJECT_KEY)_ATTR_INT
CREATE $(my_attribute[int]) $(OBJECT_KEY)_ATTR_INT
CREATE $(my_attribute[func]) $(OBJECT_KEY)_ATTR_INT
CREATE $(my_attribute[t_key]) $(OBJECT_KEY)_ATTR_INT
CREATE $(my_attribute[dllheader_ext]) $(OBJECT_KEY)_ATTR_INT
CREATE $(my_attribute[double]) $(OBJECT_KEY)_ATTR_DOUBLE
CREATE $(my_attribute[aisc_string]) $(OBJECT_KEY)_ATTR_STRING
CREATE $(my_attribute[bytestring]) $(OBJECT_KEY)_ATTR_BYTES
FOR $(STRUCT)
    IF $(JOINED)
    ELSEIF $(SKEY)
        P #define $(OBJECT_KEY)_ATTR_$(SKEY)(a,b) $|(((a)+(b))|0x4000000)
        CREATE $(my_attribute[$(STRUCT)]) $(OBJECT_KEY)_ATTR_$(SKEY)
    ENDIF
ENDFOR
P #define $(OBJECT_KEY)_ATTR_BYTES(a,b) $|(((a)+(b))|0x5000000)
--
P enum Aisc_Object_Type {
INDENT +1
    FOR $(STRUCT)
        IF $(JOINED)
        ELSEIF $(SKEY)
            P $(OBJECT_KEY)_$(SKEY) $|= 0x10000*$(SKEYC),
        ENDIF
    ENDFOR
    P $(OBJECT_KEY)_MAX $|= 0x10000*$(MAX_OBJECT),
    P $(OBJECT_KEY)_INDEX $|= 0x10000*0x1ff
INDENT -1
P };
--
FOR $(STRUCT)
    IF $(JOINED)
    ELSEIF $(SKEY)
        P struct T_$(OBJECT_KEY)_$(SKEY) : public AISC_Object {
        INDENT +1
        P T_$(OBJECT_KEY)_$(SKEY)() : AISC_Object($(OBJECT_KEY)_$(SKEY)) {}
        P void assign(const T_$(OBJECT_KEY)_$(SKEY)& o) { set(o.type(), o.get()); }
        INDENT -1
        P };
    ENDIF
ENDFOR
--

CREATE $(A)
CREATE $(add) 0
CREATE $(str) 0
CREATE $(skey) 0
CREATE $(struct) 0
CREATE $(com)

FOR $(STRUCT)
    IF $(SKEY)
        PUSH
        IF $(JOINED)
        ELSE
            P enum $(OBJECT_KEY)_$(SKEY)_Attribute { // $(SKEY)
            INDENT +1
        ENDIF
        SET $(skey) $(SKEY)
        SET $(struct) $(STRUCT)
        CALL insert_struct_attributes,0,$(SKEY)_,//
        IF $(JOIN_NEXT)
        ELSE
            P $(SKEY)_FORCELONG $|= LONG_MAX
            INDENT -1
            P };
            --
        ENDIF
        POP
    ENDIF
ENDFOR
CLOSE save

EXIT

FUNCTION insert_struct_attributes,a,s,c
    FOR $({/TYPE)
        IF $(KEY)
            IF $(TYPE) = dllh
                P $(s)PRED $|= $\
                P $(my_attribute[$(struct)])$\
                P $|($(OBJECT_KEY)_$(skey), $(+ $(a)+$(KEYC))), $|// DO

                P $(s)NEXT $|= $\
                P $(my_attribute[$(struct)])$\
                P $|($(OBJECT_KEY)_$(skey), $(+ 1+$(+ $(a)+$(KEYC)))), $|$(c)

                SET $(add) $(+ $(a)+$(KEYC))
                SET $(add) $(+ 2+$(add))
                SET $(str) $(s)$(KEY)
                PUSH
                MOVETO $(/AISC/DATA/STRUCT.dll_header)
                CALL insert_struct_attributes,$(add),$(str),$(c) H
                POP
            ELSEIF $(REF) ~ s
                SET $(add) $(+ $(a),$(KEYC))
                SET $(str) $(s)$(KEY)
                SET $(com) $(c) S
                PUSH
                MOVETO $(/AISC/DATA/STRUCT.$(TYPE))
                CALL insert_struct_attributes,$(add),$(str),$(com)
                POP
            ELSE
                IF $(REF) ~ d
                    SET $(com) $(c) DL
                ELSEIF $(REF) ~ v
                    SET $(com) $(c) [$(SIZE)]
                ELSEIF $(REF) ~ *
                    SET $(com) $(c) []
                ELSEIF $(TYPE) = func
                    SET $(com) $(c) FUNC
                ELSE
                    SET $(com) $(c)
                ENDIF
                IF $(my_attribute[$(TYPE)])
                    P $(s)$(KEY) $|= $\
                    P $(my_attribute[$(TYPE)])$\
                    P $|($(OBJECT_KEY)_$(skey), $(+ $(a)+$(KEYC))), $|$(com)
                ELSE
                    ERROR TYPE $(TYPE) unknown, no key build
                ENDIF
                IF $(REF) ~ d
                    P $(s)$(KEY)_CNT $|= $\
                    P $(my_attribute[int])$\
                    P $|($(OBJECT_KEY)_$(skey), $(+ 1,$(+ $(a)+$(KEYC)))), $|$(com)
                ENDIF
            ENDIF
        ENDIF
    ENDFOR
RETURN
