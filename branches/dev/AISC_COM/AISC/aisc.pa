# It is very important, that you set the TABSTOP to the correct tabsize of your editor,
# overwise the PRINT Command will probably make some errors
IF $(argc) = 4
ELSE
    ERROR Wrong number of parameters[$(argc)]. Usage: aisc aisc.pa xxx.aisc outfile
ENDIF

DATA AISC { $(#FILE $(argv[2])) };
DUMPDATA DUMP/aisc.pa__$(argv[2]).dump

MOVETO $(AISC/PROJECT)

OPEN save $(argv[3])
# *********************************** IDENTS ***************
CREATE $(i)
CREATE $(replace)

OUT save
MOVETO $(DATA/.)

P /* -----------------------------------------------------------------
P  * Created automagically from ../$(argv[2])
P  * using aisc-script '../AISC/aisc.pa'
P  * DO NOT EDIT THIS FILE!!!
P  * ----------------------------------------------------------------- */$n

P #ifndef AISC_GEN_SERVER_INCLUDED
P #define AISC_GEN_SERVER_INCLUDED$n

P typedef int         hash;
P typedef char       *aisc_string;
P typedef const char *aisc_cstring;

P $n#include <aisc_global.h>

P $(INCLUDE_INCLUDES)

IF $(CONST)
    P $n// some constants
    FOR $(CONST)
        P #define $(CONST) $|$(VALUE) $|// $(DOCU)
    ENDFOR
ENDIF

IF $(ENUM)
    ERROR never used before - please check generated code
    P $n// the enums
    FOR $(ENUM)
        P $n// $(SDOCU|$(ENUM))
        P typedef enum enum_$(ENUM) {
        INDENT +1
            FOR $({/VAR)
                IF $(VAL)
                    P $(VAR)$| = $|$(VAL),$\
                ELSE
                    P $(VAR),$|$\
                ENDIF
                IF $(DOCU)
                    P $|// $(DOCU)
                ELSE
                    P 
                ENDIF
            ENDFOR
        INDENT -1
        P } $(ENUM);
    ENDFOR
ENDIF

P $n// the keys
P typedef enum enum_t_key {
INDENT +1
    FOR $(STRUCT)
        IF $(JOINED)
        ELSEIF $(SKEY)
            P KEY_$(OBJECT_KEY)_$(SKEY)$| = $|0x10000*$(SKEYC),
        ENDIF
    ENDFOR
    P KEY_MAX
INDENT -1
P } t_key;

P $n// forward decls
FOR $(STRUCT)
    P struct $(STRUCT);
ENDFOR

CREATE $(pre)
CREATE $(suf)

P struct dllpublic_ext;
P struct dllheader_ext;

P $n// private structures$n
FOR $(STRUCT.dll_public)
    P struct dllpublic_ext {
    INDENT +1
        SET $(replace) :dll_header=dllheader_ext:dll_public=dllpublic_ext
        CALL structh
        P dllheader_ext$| *first;
    INDENT -1
    P };
NEXT
    ERROR struct dll_public is missing
ENDFOR

P 
FOR $(STRUCT.dll_header)
    P struct dllheader_ext {
    INDENT +1
        SET $(replace) :dll_header=dllheader_ext:dll_public=dllpublic_ext
        CALL structh
        P dllheader_ext$| *previous, *next;
    INDENT -1
    P };
NEXT
    ERROR struct dll_header is missing
ENDFOR

P $n// public structures
FOR $(STRUCT)
    P $nstruct $(STRUCT) { // $(SDOCU|$(STRUCT))
    INDENT +1
        SET $(replace)
        CALL structh
    INDENT -1
    P };
ENDFOR

P $nextern const char *aisc_server_error;

P $n#else 
P #error header included twice 
P #endif /* AISC_GEN_SERVER_INCLUDED */
CLOSE save
GOTO harmless_test_code
#EXIT

FUNCTION structh
    FOR $({/TYPE)
        IF $(TYPE) = dllh
            P dll_header$|  mh;
            P $(STRUCT)$| *previous, *next;$n
        ELSEIF $(REF) ~ %
        ELSE
            SET $(pre)
            SET $(suf)
            IF $(REF) ~ *
                SET $(pre) *
            ELSEIF $(REF) ~ v
                SET $(suf) [$(SIZE|NO SIZE DEFINED)]
            ENDIF
            IF $(REF) ~ d
                P dll_public$|  p$(IDENT);
            ENDIF
            IF $(REF) ~ d,r,l,o
                SET $(pre) $(pre)*
            ENDIF
            IF $(REF) ~ f
                P $(TYPE|NO TYPE FOUND$(replace))$\
            ELSE
                P $(TYPE|NO TYPE FOUND$(replace))$\
            ENDIF

            # align
            #   name
            #  *name
            # **name

            SET $(pre) '$(pre)'
            P $|$(pre:''=  :'*'= *:'**'=**:'=)$(IDENT)$(suf);$\
            P $| // $(DOCU| *** )
        ENDIF
    ENDFOR
RETURN

# ---------------------------------
# testing GOTO (not used elsewhere)

LABEL harmless_test_code

GOTO test_goto_label
ERROR never reached
LABEL test_goto_label

#ERROR reached

# test deadlock (should print a )
#GOTO test_goto_label

EXIT

# ---------------------------------

