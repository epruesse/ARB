
IF $(argc) = 6
ELSE
	ERROR	Falsche Parameteranzahl: Syntax aisc xxx.pa xxx.aisc externfile.aisc outfile import_proto
ENDIF

DATA AISC { $(#FILE $(argv[2])) }, EXTERN { $(#FILE $(argv[4])) };
OPEN save $(argv[3]) 
OPEN import $(argv[5])
# ************************* SET EXTERN FUNCTIONS ***************************
MOVETO $(EXTERN/.)
OUT save
FOR $(FUNCTION)
	CREATE $(extern_$(FUNCTION))
NEXT
	PP no extern Functions found
ENDFOR
# ***************************************************************************
MOVETO $(/AISC/PROJECT)
OUT import

P /*********************************************************************
P  * Created automagically from $(argv[2]) and $(argv[4])
P  * using aisc-script 'aisc_server.pa'
P  * DO NOT EDIT THIS FILE!!!
P  *********************************************************************/$n

OUT save
MOVETO $(DATA/.)
P /*********************************************************************
P  * Created automagically from $(argv[2]) and $(argv[4])
P  * using aisc-script 'aisc_server.pa'
P  * DO NOT EDIT THIS FILE!!!
P  *********************************************************************/$n
P $(#FILE C/aisc_server.h)$n

TABSTOP 8
TAB	0	0
TAB	1	8
TAB	2	16
TAB	3	24
TAB	4	32
TAB	5	40
TAB	6	48
TAB	7	56
TAB	8	64
TAB	9	72

CREATE $(v) = %
CREATE $(i) = 0
CREATE $(sp) = 0

# Tabellen initialisieren
FOR $(i) = 0 TO $(MAX_KEY)
	CREATE $(set_list[$(i)]) 0,
	CREATE $(get_list[$(i)]) 0,
	CREATE $(create_list[$(i)]) 0,
	CREATE $(find_list[$(i)]) 0,
	CREATE $(copy_list[$(i)]) 0,
ENDFOR
# Variablen deklarieren
CREATE $(add)
CREATE $(conds)
CREATE $(func)
CREATE $(access)
CREATE $(maintype)
CREATE $(conds_init)
CREATE $(index) #

P /************* MALLOC ******************/
FOR $(STRUCT)
	P $(STRUCT) *create_$(STRUCT)()$\
	IF $(extern_create_$(STRUCT))
		P ;
	ELSE
		P $n$1{$n$1$(STRUCT) *THIS$5= ($(STRUCT) *)calloc(sizeof($(STRUCT)), 1);
		P $1if(!THIS){ aisc_server_error = "Malloc error in create_$(STRUCT) !"; return 0;}
		SET $(maintype) $(STRUCT)
		SET $(access) THIS->
		GOSUB init_structure
		P $1return THIS; }$n
	ENDIF
ENDFOR

P /************* MOVE ******************/
FOR $(STRUCT)
	P int move_$(STRUCT)($(STRUCT) *sobj,$(STRUCT) *dobj)$\
	IF $(extern_move_$(STRUCT))
		P ;
	ELSE
		P { 
#int i = 0;
		SET $(maintype) $(STRUCT)
		GOSUB move_structure
		P $1return 0; }$n
	ENDIF
ENDFOR

P /************* COPY ******************/
FOR $(STRUCT)
	P $(STRUCT) *copy_$(STRUCT)($(STRUCT) *sobj)$\
	IF $(extern_copy_$(STRUCT))
		P ;
	ELSE
		P {
		P $1$(STRUCT) *dobj;
		P $1if(!sobj) return 0;
		P $1dobj$5= create_$(STRUCT)();
		P $1if(!dobj){ aisc_server_error = "Malloc error in copy_$(STRUCT) !"; return 0;}
		P $1trf_create((long)sobj,(long)dobj);
		P $1if (move_$(STRUCT)(sobj,dobj)) return 0;
		P $1return dobj; }$n
	ENDIF
ENDFOR


# /************* DELETE ******************/
IF $(extern_destroy_char)
	P void destroy_char(char *obj);
ELSE
	P void destroy_char(char *obj){ free(obj); }
ENDIF

FOR $(STRUCT)
	P void destroy_$(STRUCT)($(STRUCT) *obj)$\
	IF $(extern_destroy_$(STRUCT))
		P ;
	ELSE
		P {
		PUSH
		MOVETO $({/.)
		IF $(TYPE) = dllh
			P $1if (obj->$(IDENT).parent) {
			P $2aisc_unlink((dllheader_ext*)obj);
			P $2if (aisc_server_error) return;
			P $1}
		ENDIF
		POP
		SET $(maintype) $(STRUCT)
		SET $(access) obj->
		SET $(index) #
		GOSUB delete_structure
		P $1free((char *)obj);
		P }$n
	ENDIF
ENDFOR

P /************** SAVE and LOAD **************/
P #ifdef AISC_SAVE_YES

CREATE $(TOKENSIZE) 1024

GOSUB save_token

CREATE $(prekey)
FOR $(STRUCT)
	P int save_$(STRUCT)($(STRUCT) *THIS, FILE *THIS_FD)$\
	IF $(extern_save_$(STRUCT))
		P ;
	ELSE
		P {$n
		SET $(maintype) $(STRUCT)
		SET $(access) THIS->
		GOSUB save_structure
		P $1return 0;
		P $1}$n
	ENDIF
ENDFOR


GOSUB load_token

FOR $(STRUCT)
	P int load_$(STRUCT)($(STRUCT) *THIS, FILE *THIS_FD)$\
	IF $(extern_load_$(STRUCT))
		P ;
	ELSE
		P {$n
		P $1char token[$(TOKENSIZE)+1];
		P $1while (!aisc_server_load_token(THIS_FD,token,$(TOKENSIZE))) {
		P $2if (*token == '}') { return 0;
				# the } symbol is }else if
		SET $(maintype) $(STRUCT)
		SET $(access) THIS->
		GOSUB load_structure
		P $2}else{
		P $3printf("Undefined Token %s\n",token);
		P $2} /* if token */
		P $1} /*while */
		P $1return 0;
		P $1}$n
	ENDIF
ENDFOR

P #endif


# /************* GET SET CREATE FIND COPY ******************/

FOR $(STRUCT)
	IF $(SKEY)
		P /************* FUNCTIONS $(STRUCT) *****************/$n
		IF $(JOINED)
		ELSE
			FOR $(i) = 0 TO $(MAX_KEY)
				SET $(set_list[$(i)]) $10,
				SET $(get_list[$(i)]) $10,
				SET $(create_list[$(i)]) $10,
				SET $(find_list[$(i)]) $10,
				SET $(copy_list[$(i)]) $10,
			ENDFOR
		ENDIF
		SET $(add) 0
		SET $(conds) = #
		SET $(func) $(SKEY)_
		SET $(access) THIS->
		SET $(maintype) $(STRUCT)
		SET $(conds_init) 
		SET $(index) #
		GOSUB rec_structure
		IF $(JOIN_NEXT)
		ELSE
			GOSUB print_tabs
		ENDIF
	ENDIF
ENDFOR
CLOSE save
EXIT


FUNCTION rec_structure
		# Function name
	CREATE $(f) $(func)
		# relative key
	CREATE $(a) $(add)
		# conditions
	CREATE $(c) $(conds)
	CREATE $(ci) $(conds_init)
		# path
	CREATE $(ac) $(access)
	CREATE $(in) $(index)
	CREATE $(type)
	FOR $({/KEY)
		SET $(func) $(f)$(KEY)
		SET $(conds) $(c)

		IF $(TYPE) = dllh
			IF $(get_list[$(+ 0+$(+ $(a)+$(KEYC)))]) ~ 0
                        ELSE
                                ERROR Number for 'get_$(func)PRED:$(KEYC)' already in use: '$(get_list[$(+ 0+$(+ $(a)+$(KEYC)))])'
                        ENDIF
			SET $(get_list[$(+ 0+$(+ $(a)+$(KEYC)))])	get_$(func)PRED,
			P $(maintype) $1*get_$(func)PRED($(maintype)$4 *THIS)$\
			IF $(extern_get_$(func)PRED)
				P ;
			ELSE
				P {$\
				GOSUB create_access
				GOSUB create_condition
				P $3return ($(maintype) *)$(ac)previous;}
			ENDIF
			IF $(get_list[$(+ 1+$(+ $(a)+$(KEYC)))]) ~ 0
                        ELSE
                                ERROR Number for 'get_$(func)NEXT:$(KEYC)' already in use: '$(get_list[$(+ 1+$(+ $(a)+$(KEYC)))])'
                        ENDIF
			SET $(get_list[$(+ 1+$(+ $(a)+$(KEYC)))])	get_$(func)NEXT,
			P $(maintype) $1*get_$(func)NEXT($(maintype)$4 *THIS)$\
			IF $(extern_get_$(func)NEXT)
				P ;
			ELSE
				P {$\
				GOSUB create_access
				GOSUB create_condition
				P $3return ($(maintype) *)$(ac)next;}
			ENDIF
			PUSH
			SET $(add) $(+ 2+$(+ $(a)+$(KEYC)))
			SET $(access) $(ac)$(IDENT).
			SET $(conds_init) $(ci)
			MOVETO $(/AISC/DATA/STRUCT.dll_header)
			GOSUB rec_structure
			POP
			CONTINUE
		ENDIF

		SET $(index) $(in)
		SET $(access) $(ac)$(IDENT)
		SET $(conds_init) $(ci)

		IF $(REF) ~ *
			SET $(conds) $(conds)&&($(access))
			SET $(index) $(SIZE:THIS->=$(ac))
			IF $(REF) ~ o,d,l,r
				SET $(type) $(TYPE) *
			ELSE
				SET $(type) $(TYPE)
			ENDIF
			SET $(conds_init) $(conds_init)$3if(!$(access)) $(access) = ($(type)*)calloc(sizeof($(type)),$(index));$n
			SET $(access) $(access)[index]
		ELSEIF $(REF) ~ v
			SET $(index) $(SIZE:THIS->=$(ac))
			SET $(access) $(access)[index]
		ENDIF
		IF $(REF) ~ s
			IF $(REF) ~ o,l,r
				SET $(conds) $(conds)&&($(access))
				SET $(conds_init) $(conds_init)$3if(!$(access)) $(access) = create_$(TYPE)();$n
				SET $(access) $(access)->
			ELSEIF $(REF) ~ i
				SET $(access) $(access).
			ENDIF
			PUSH
			SET $(add) $(+ $(a)+$(KEYC))
			MOVETO $(/AISC/DATA/STRUCT.$(TYPE))
			CALL rec_structure
			POP
			CONTINUE
		ENDIF
		IF $(REF) ~ o,d
	# ********************************** CREATE FUNCTIONS ****************************
			IF $(ACC) !~ c
			ELSE
				IF $(create_list[$(+ $(a)+$(KEYC))]) ~ 0
				ELSE
                                        ERROR Number for 'create_$(func):$(KEYC)' already in use: '$(create_list[$(+ $(a)+$(KEYC))])'
				ENDIF
				SET $(create_list[$(+ $(a)+$(KEYC))])	create_$(func),
				P $(TYPE) $1*create_$(func)($(maintype) *THIS)$\
				IF $(extern_create_$(func))
					P ;
				ELSE
					P {$\
					P $(TYPE) *obj;
					CALL create_index y,0
					CALL create_condition
					P $3obj = create_$(TYPE)();
					P $3if(!obj) { aisc_server_error = "MALLOC ERROR in create_$(func)"; return 0; }
					P $3aisc_make_sets((long *)obj);
					P $3if(aisc_server_error) {
					P $4destroy_$(TYPE)(obj);
					P $4return 0;
					P $3}
					IF $(REF) ~ d
						P $3aisc_server_error = aisc_link((dllpublic_ext*)&($(ac)p$(IDENT)),(dllheader_ext*)obj);
					ELSE
						P $3if ($(access)) destroy_$(TYPE)($(access));
						P $3$(access) = obj;
					ENDIF
					P $3return obj;}
				ENDIF
	# ********************************** COPY FUNCTIONS ****************************
				IF $(copy_list[$(+ $(a)+$(KEYC))]) ~ 0
                                ELSE
                                        ERROR Number for 'copy_$(func):$(KEYC)' already in use: '$(copy_list[$(+ $(a)+$(KEYC))])'
                                ENDIF
				SET $(copy_list[$(+ $(a)+$(KEYC))])	copy_$(func),
				P $(TYPE) $1*copy_$(func)($(maintype)$4 *THIS)$\
				IF $(extern_copy_$(func))
					P ;
				ELSE
					P {$\
					P $(TYPE) *obj;
					CALL create_index y,0
					CALL create_condition
					P $3trf_begin();
					P $3obj$4= copy_$(TYPE)($(access));
					P $3trf_commit(0);
					P $3if(!obj) { aisc_server_error = "MALLOC ERROR in create_$(func)"; return 0; }
					P $3aisc_make_sets((long *)obj);
					P $3if(aisc_server_error) {
					P $4destroy_$(TYPE)(obj);
					P $4return 0;
					P $3}
					IF $(REF) ~ d
						P $3aisc_server_error = aisc_link((dllpublic_ext*)&($(ac)p$(IDENT)),(dllheader_ext*)obj);
					ELSE
						P $3if ($(access)) destroy_$(TYPE)($(access));
						P $3$(access) = obj;
					ENDIF
					P $3return obj;}
				ENDIF
			ENDIF
	# ********************************** FIND FUNCTIONS ****************************
			IF $(ACC) !~ f
			ELSEIF $(REF) ~ d
				IF $(find_list[$(+ $(a)+$(KEYC))]) ~ 0
                                ELSE
                                        ERROR Number for 'find_$(func):$(KEYC)' already in use: '$(find_list[$(+ $(a)+$(KEYC))])'
                                ENDIF
				SET $(find_list[$(+ $(a)+$(KEYC))])	find_$(func),
				P $(TYPE) $1*find_$(func)($(maintype)$4 *THIS,char *key)$\
				IF $(extern_find_$(func))
					P ;
				ELSE
					P {$\
					P $(TYPE) *obj;$\
					GOSUB create_access
					GOSUB create_condition
					P $3obj = ($(TYPE)*)aisc_read_hash((struct aisc_hash_node**)$(ac)p$(IDENT).hash,key);
					P $3return obj;}
				ENDIF
			ENDIF
	# ********************************** CNT FUNCTION ****************************
			IF $(REF) ~ d
        			IF $(get_list[$(+ 1 +$(+ $(a)+$(KEYC)))]) ~ 0
	        		ELSE
		        		ERROR Number for get_$(func)_CNT:$(KEYC) already in use: '$(get_list[$(+ 1 +$(+ $(a)+$(KEYC)))])'
			        ENDIF
				SET $(get_list[$(+ 1 +$(+ $(a)+$(KEYC)))])	get_$(func)_CNT,
				IF $(extern_get_$(func)_CNT)
	#				P ;
				ELSE
					P int $1get_$(func)_CNT($(maintype) *THIS)$\
					P {$\
					GOSUB create_access
					GOSUB create_condition
					P $3return $(ac)p$(IDENT).cnt;}
				ENDIF
			ENDIF
	#***************** SET FUNCTIONS *********************
		ELSE
			IF $(set_list[$(+ $(a)+$(KEYC))]) ~ 0
			ELSE
				ERROR Number for set $(KEY):$(KEYC) already in use: '$(set_list[$(+ $(a)+$(KEYC))])'
			ENDIF

			IF $(ACC) !~ w
			ELSEIF $(REF) ~ $(v)
				IF $(extern_$(IDENT))
					SET $(set_list[$(+ $(a)+$(KEYC))])	$(IDENT),
				ELSE
					SET $(set_list[$(+ $(a)+$(KEYC))])	$(IDENT),
					OUT import	# Generate Prototypes for import
					P extern int $1$(IDENT)($(maintype)*, $(TYPE:bytestring=bytestring *)); /* (1) */
					OUT save
				ENDIF
			ELSE
				SET $(set_list[$(+ $(a)+$(KEYC))])	set_$(func),
				IF $(REF) ~ o,l,r
					P void $1set_$(func)($(maintype)$4 *THIS,$(TYPE) *x)$\
				ELSEIF $(REF) ~ t,e
					P void $1set_$(func)($(maintype)$4 *THIS,$(TYPE:bytestring=bytestring *) x)$\
				ELSE
					ERROR UNKNOWN REF '$(REF|)' in $(STRUCT).$(TYPE)
				ENDIF
				IF $(extern_set_$(func))
					P ;
				ELSE
					P {
					GOSUB create_index n,n
					GOSUB create_vterms
				#	GOSUB create_access_noval
					GOSUB create_condition
					IF $(TYPE) = aisc_string
						P $3if($(access)) free($(access));
						P $3$(access) = x;}
					ELSEIF $(TYPE) = bytestring
						P $3if($(access).data) free($(access).data);
						P $3if(x){
						P $4$(access).data$6= x->data;
						P $4$(access).size$6= x->size;
						P $3}else{
						P $4$(access).data$6= 0;
						P $4$(access).size$6= 0;
						P $3}
						P $2}
					ELSE
						IF $(REF) ~ o
							P $3if ($(access))
							P $4destroy_$(TYPE)($(access));
						ENDIF
						P $3$(access)$5= x;}
					ENDIF
				ENDIF
			ENDIF
		ENDIF
	#**************** GET FUNCTIONS *********************
		IF $(get_list[$(+ $(a)+$(KEYC))]) ~ 0
		ELSE
			ERROR Number for get $(KEY):$(KEYC) already in use: '$(get_list[$(+ $(a)+$(KEYC))])'
		ENDIF
		IF $(ACC) !~ r
		ELSEIF $(REF) ~ $(v)
			IF $(extern_$(IDENT))
				SET $(get_list[$(+ $(a)+$(KEYC))])	$(IDENT),
			ELSE
				IF $(IDENT) = aisc_get_keystring
					SET $(get_list[$(+ $(a)+$(KEYC))])	(const char*(*)(int*))$(IDENT),/* special cast for aisc_get_keystring */
				ELSE
					SET $(get_list[$(+ $(a)+$(KEYC))])	($(TYPE:bytestring=bytestring *)(*)($(maintype)*))$(IDENT),/* explicit cast to overloaded function type before casting to void */
				ENDIF
				OUT import	# Generate Prototypes for import
				P extern $(TYPE:bytestring=bytestring *)  $2$(IDENT)($(maintype)*); /* (2) */
				OUT save
			ENDIF

		ELSE
			SET $(get_list[$(+ $(a)+$(KEYC))])	get_$(func),
			IF $(extern_get_$(func))
			ELSE
				IF $(REF) ~ o,l,r,d
					P $(TYPE) $1*get_$(func)$\
				ELSEIF $(REF) ~ e,t
					P $(TYPE:bytestring=bytestring *) $1get_$(func)$\
				ELSE
					ERROR UNKNOWN REF '$(REF|)' in $(STRUCT).$(TYPE)
				ENDIF
				P ($(maintype)$4 *THIS)$\
				P {$\
				GOSUB create_index y,0
				GOSUB create_condition
				IF $(TYPE) = bytestring
					P $3return &($(access));}
				ELSE
					P $3return $(access);}
				ENDIF
			ENDIF
		ENDIF
	ENDFOR
RETURN

# ***************************** free a structure *******************************
FUNCTION delete_structure
	CREATE $(ac) $(access)
	CREATE $(end)
	CREATE $(start)
	CREATE $(in) $(index)
	FOR $({/TYPE)

		SET $(index) $(in)
		SET $(access) $(ac)$(IDENT)
		SET $(end)
		IF $(DESTROY)
			P $1$(DESTROY:THIS=obj);
		ELSEIF $(REF) ~ $(v)
				#virtuell function
		ELSE
			IF $(REF) ~ *,v
				SET $(index) $(SIZE:THIS->=$(ac))
				IF $(REF) ~ *
					P $1if($(access)) $\
					SET $(end) $1}free((char *)$(access));}$n
				ELSE
					SET $(end) $1}}$n
				ENDIF
				P $1{int index;
				P $1for (index = 0; index < $(index); index++) {
				SET $(access) $(access)[index]
			ENDIF
			IF $(TYPE) = dllh
				SET $(access) $(access).
				PUSH
				MOVETO $(/AISC/DATA/STRUCT.dll_header)
				GOSUB delete_structure
				POP
			ELSEIF $(REF) ~ s
				IF $(REF) ~ o,d,i
					PUSH
					IF $(REF) ~ i
						CREATE $(access) $(access).
					ELSE
						P $1if($(access)) {
						CREATE $(access) $(access)->
					ENDIF
					MOVETO $(/AISC/DATA/STRUCT.$(TYPE))
					GOSUB delete_structure
					POP
					IF $(REF) !~ i
						P $1free$2((char *)$(access));}
					ENDIF
				ENDIF
			ELSEIF $(REF) ~ d
				P $1while ($(access)) {
				P $2destroy_$(TYPE)($(access));
				P $2if (aisc_server_error)$5return;}
			ELSEIF $(REF) ~ o
				P $1if ($(access))$4destroy_$(TYPE)($(access));
				P $1if (aisc_server_error)$5return;
			ELSEIF $(REF) ~ t,e
				IF $(TYPE) = aisc_string
					P $1if($(access))$4free($(access));
				ELSEIF $(TYPE) = bytestring
					P $3if($(access).data) free($(access).data);
				ENDIF
			ELSEIF $(REF) ~ l
			ELSE
				ERROR UNKNOWN REF '$(REF|)' in $(STRUCT).$(TYPE)
			ENDIF
			P $(end)$\
		ENDIF
	ENDFOR
RETURN

# ***************************** save a structure *******************************
FUNCTION save_structure
	CREATE $(ac) $(access)
	CREATE $(end)
	CREATE $(start)
	CREATE $(in) $(index)
	CREATE $(prekey) $(prekey)
	FOR $({/TYPE)

		SET $(index) $(in)
		SET $(access) $(ac)$(IDENT)
		SET $(end)
		IF $(REF) ~ $(v)
				#virtuell function
		ELSEIF $(SAVE)
			IF $(REF) ~ *,v
				SET $(index) $(SIZE:THIS->=$(ac))
				IF $(REF) ~ *
					P $1if($(access)) $\
					SET $(end) $1}}$n
				ELSE
					SET $(end) $1}}$n
				ENDIF
				P $1{int index;
				P $1for (index = 0; index < $(index); index++) {
				SET $(access) $(access)[index]
			ENDIF
			IF $(TYPE) = dllh
				SET $(access) $(access).
				PUSH
				CREATE $(prekey) $(prekey)$(KEY)
				MOVETO $(/AISC/DATA/STRUCT.dll_header)
				GOSUB save_structure
				POP
			ELSEIF $(REF) ~ s		#sub structure
				IF $(REF) ~ o,d,i
					PUSH
					IF $(REF) ~ i
						CREATE $(access) $(access).
					ELSE
						P $1if($(access)) {
						CREATE $(access) $(access)->
					ENDIF
					CREATE $(prekey) $(prekey)$(KEY|NOKEYDEFINED)
					MOVETO $(/AISC/DATA/STRUCT.$(TYPE))
					GOSUB save_structure
					POP
					P $1};
				ENDIF
			ELSEIF $(REF) ~ d
				P $1{$(TYPE) *cobj;
				P $2for(cobj = $(access);cobj;cobj=cobj->next) {
				P $3int error;
				P $3fprintf(THIS_FD,"$(prekey)$(KEY|NOKEYDEFINED){ ");
				P $3error = save_$(TYPE)(cobj,THIS_FD);
				P $3if (error) return error;
				P $3fprintf(THIS_FD,"}\n");
				P $1}};
			ELSEIF $(REF) ~ o
				P $1fprintf(THIS_FD,"$(prekey)$(KEY) {\n");
				P $1{ int error = save_$TYPE($(access),THIS_FD);
				P $1if (error) return error; }
				P $1fprintf(THIS_FD,"}\n");
			ELSEIF $(REF) ~ t,e
				IF $(TYPE) = aisc_string
					P $1if ($(access)){
					P $2fprintf(THIS_FD,"$(prekey)$(KEY|NOKEYDEFINED) ");
					P $2aisc_server_save_token(THIS_FD,$(access),$(TOKENSIZE));}
				ELSEIF $(TYPE) = int,long,char
					P $1fprintf(THIS_FD,"$(prekey)$(KEY|NOKEYDEFINED) %i\n",$(access));
				ELSEIF $(TYPE) = float,double
					P $1fprintf(THIS_FD,"$(prekey)$(KEY|NOKEYDEFINED) %f\n",$(access));
				ELSE
					ERROR CANNOT SAVE TYPE '$(TYPE)'
				ENDIF
			ELSEIF $(REF) ~ l
				P $1fprintf(THIS_FD,"$(prekey)$(KEY|NOKEYDEFINED) %i",$(access));
			ELSE
				ERROR UNKNOWN REF '$(REF|)' in $(STRUCT).$(TYPE)
			ENDIF
			P $(end)$\
		ENDIF
	ENDFOR
RETURN

# ***************************** load a structure *******************************
FUNCTION save_token
	P int aisc_server_save_token(FILE *fd,char *buffer, int maxsize){
	P $1register char *p;
	P $1register int c;
	P $1putc('{',fd);
	P $1p = buffer;
	P $1while(maxsize-->0){
	P $1	c = *(p++);if (!c) break;
	P $1	if (c=='}' || c == '\\') putc('\\',fd);
	P $1	putc(c,fd);
	P $1}
	P $1putc('}',fd);
	P $1return 0;
	P $1}
RETURN


FUNCTION load_token
	P int aisc_server_load_token(FILE *fd,char *buffer, int maxsize)
	P $1{
	P $1register char *p;
	P $1register int c;
	P $1register int in_brackets = 0;
	P $1p = buffer;
	P $1while(maxsize-->0){
	P $2c = getc(fd);
	P $2if (c==EOF) { *p=0; return EOF;}
	P $2else if(in_brackets) {
	P $2	if (c=='\\') { c = getc(fd); *(p++) = c; continue; }
	P $2	if (c!='}') *(p++) = c;else {*p=0;return 0;}
	P $2}else if (c=='{'){ if (p!=buffer) {*(p++) = '{';*p=0;return 0;}
	P $2			else	in_brackets = 1; }
	P $2else if (c==' '){ if (p!=buffer) {*p=0;return 0;} }
	P $2else if (c=='\n'){ if (p!=buffer) {*p=0;return 0;} }
	P $2else if (c=='}') {*(p++) = '}'; *p=0;return 0;}
	P $2else *(p++) = c;
	P $1}
	P $1*p = 0; return EOF;	/* read error maxsize reached */
	P $1}
RETURN

FUNCTION load_structure
	CREATE $(ac) $(access)
	CREATE $(end)
	CREATE $(start)
	CREATE $(in) $(index)
	CREATE $(prekey) $(prekey)
	FOR $({/TYPE)

		SET $(index) $(in)
		SET $(access) $(ac)$(IDENT)
		SET $(end)
		IF $(REF) ~ $(v)
				#virtuell function
		ELSEIF $(SAVE)
			IF $(REF) ~ *,v
				SET $(index) $(SIZE:THIS->=$(ac))
				IF $(REF) ~ *
					P $1if($(access)) $\
					SET $(end) $1}}$n
				ELSE
					SET $(end) $1}}$n
				ENDIF
				P $1{int index;
				P $1for (index = 0; index < $(index); index++) {
				SET $(access) $(access)[index]
			ENDIF
			IF $(TYPE) = dllh
				SET $(access) $(access).
				PUSH
				CREATE $(prekey) $(prekey)$(KEY)
				MOVETO $(/AISC/DATA/STRUCT.dll_header)
				GOSUB load_structure
				POP
			ELSEIF $(REF) ~ s		#sub structure
				IF $(REF) ~ o,d,i
					PUSH
					IF $(REF) ~ i
						CREATE $(access) $(access).
					ELSE
						P $1if($(access)) {
						CREATE $(access) $(access)->
					ENDIF
					CREATE $(prekey) $(prekey)$(KEY|NOKEYDEFINED)
					MOVETO $(/AISC/DATA/STRUCT.$(TYPE))
					GOSUB load_structure
					POP
					P $1};
				ENDIF
			ELSEIF $(REF) ~ d
				P $2}else if( !strcmp("$(prekey)$(KEY|NOKEYDEFINED){",token) ) {
				P $3$(TYPE) *cobj = create_$(TYPE)();
				P $3{ int error = load_$(TYPE)(cobj,THIS_FD);
				P $3if(error) return error; }
				P $3aisc_link((dllpublic_ext*)&($(ac)p$(IDENT)),(dllheader_ext*)cobj);
			ELSEIF $(REF) ~ o
				P $1fprintf(THIS_FD,"$(prekey)$(KEY) {\n");
				P $1{ int error = save_$TYPE($(access),THIS_FD);
				P $1if (error) return error; }
				P $1fprintf(THIS_FD,"}\n");
			ELSEIF $(REF) ~ t,e
				P $2}else if( !strcmp("$(prekey)$(KEY|NOKEYDEFINED)",token) ) {
				P $3if (aisc_server_load_token(THIS_FD,token,$(TOKENSIZE))) return 1;
				IF $(TYPE) = aisc_string
					P $3$(access) = strdup(token);
				ELSEIF $(TYPE) = int,long,char
					P $3$(access) = atoi(token);
				ELSEIF $(TYPE) = float,double
					P $3$(access) = atof(token);
				ELSE
					ERROR CANNOT SAVE TYPE '$(TYPE)'
				ENDIF
			ELSEIF $(REF) ~ l
				P I cannot load links yet
			ELSE
				ERROR UNKNOWN REF '$(REF|)' in $(STRUCT).$(TYPE)
			ENDIF
			P $(end)$\
		ENDIF
	ENDFOR
RETURN



# ***************************** init a structure *******************************
FUNCTION init_structure
	CREATE $(ac) $(access)
	CREATE $(end)
	CREATE $(my_key)
	CREATE $(index)
	FOR $({/TYPE)

		SET $(index)
		SET $(access) $(ac)$(IDENT)
		SET $(end)
		IF $(REF) ~ $(v)
		ELSE
			IF $(REF) ~ v
				SET $(index) $(SIZE:THIS->=$(ac))
				SET $(end) $1}}$n
				P $1{int index; for (index = 0; index < $(index); index++) {
				SET $(access) $(access)[index]
			ENDIF
			IF $(TYPE) = dllh
				P $1$(access).key$5= KEY_$(OBJECT_KEY)_$(SKEY|COMMON);
				SET $(access) $(access).
				PUSH
				MOVETO $(/AISC/DATA/STRUCT.dll_header)
				GOSUB init_structure
				POP
			ELSEIF $(REF) ~ d
				P $1$(ac)p$(IDENT).parent$5= (dllheader_ext *)THIS;
				PUSH
					MOVETO $(/AISC/DATA/STRUCT.$(TYPE))
					SET $(my_key) $(SKEY|SKEY_missing)
				POP
				P $1$(ac)p$(IDENT).key$5= KEY_$(OBJECT_KEY)_$(my_key);
			ELSEIF $(REF) ~ s
				IF $(REF) ~ i
					PUSH
					CREATE $(access) $(access).
					MOVETO $(/AISC/DATA/STRUCT.$(TYPE))
					GOSUB init_structure
				POP
				ENDIF
			ELSEIF $(REF) ~ t,e,l
				IF $(IDENT) = key
					IF $(SKEY) !~ COMMON
						P $1$(access)$5= KEY_$(OBJECT_KEY)_$(SKEY|COMMON);
					ENDIF
				ELSEIF $(INIT)
					IF $(TYPE) = aisc_string
						P $1$(access)$5= (char *)strdup($(INIT));
					ELSE
						P $1$(access)$5= $(INIT);
					ENDIF
				ENDIF
			ELSE
				PP UNKNOWN REF '$(REF|)' in $(STRUCT).$(TYPE)

			ENDIF
			P $(end)$\
		ENDIF
	ENDFOR
RETURN

# ***************************** move a structure *******************************
FUNCTION move_structure
	CREATE $(access)
	CREATE $(end)
	CREATE $(my_key)
	CREATE $(index)
	FOR $({/TYPE)
		SET $(index)
		SET $(access) $(IDENT)
		SET $(end)
		IF $(REF) ~ $(v)
		ELSEIF $(IDENT) = key
		ELSE
			IF $(REF) ~ *,v
				IF $(SIZE)
					SET $(index) $(SIZE:THIS->=sobj->)
				ELSE
					ERROR Missing SIZE in STRUCT $(STRUCT) ident $(IDENT)
				ENDIF
				IF $(REF) ~ *
					P $1if(dobj->$(access))$4$\
				ENDIF
				SET $(end) $1}}$n
				P $1{int index;
				P $1for (index = 0; index < $(index); index++) {
				SET $(access) $(access)[index]
			ENDIF
			IF $(TYPE) = dllh
				P $1move_dll_header(&(sobj->$(access)),&(dobj->$(access)));
			ELSEIF $(REF) ~ l,r
				P $1dobj->$(access)$4= sobj->$(access);
				P $1trf_link((long)sobj->$(access), (long*)&dobj->$(access));
			ELSEIF $(REF) ~ o
				P $1dobj->$(access)$4= copy_$(TYPE)(sobj->$(access));
			ELSEIF $(REF) ~ d
				P $1{$(TYPE) *cobj,*d2obj;
				P $1for(cobj = sobj->$(access);cobj;cobj=cobj->next) {
				P $2d2obj$4= copy_$(TYPE)(cobj);
				P $2if (!d2obj) return 1;
				P $2aisc_server_error = aisc_link((dllpublic_ext*)&(dobj->p$(access)),(dllheader_ext*)d2obj);
				P $2if(aisc_server_error)return 1;
				P $1}};
			ELSEIF $(REF) ~ s
				IF $(REF) ~ i
					P $1if (move_$(TYPE)(&(sobj->$(access)),&(dobj->$(access)))) return 1;
				ENDIF
			ELSEIF $(REF) ~ t,e
				IF $(TYPE) = aisc_string
					P $1if (sobj->$(access)) {
					P $2dobj->$(access)$4= strdup(sobj->$(access));}
				ELSEIF $(TYPE) = bytestring
					P $1if(sobj->$(access).data) {
					P $2dobj->$(access).data = (char *)malloc(sobj->$(access).size);
					P $2memcpy(dobj->$(access).data, sobj->$(access).data, sobj->$(access).size);
					P $2dobj->$(access).size=sobj->$(access).size;
					P $2}
				ELSE
					P $1dobj->$(access)$4= sobj->$(access);
				ENDIF
			ELSE
				PP UNKNOWN REF '$(REF|)' in $(STRUCT).$(TYPE)
			ENDIF
			P $(end)$\
		ENDIF
	ENDFOR
RETURN

# ***************************** create the condition *******************************
FUNCTION create_condition
	IF $(COND:==)
		P $n$3if(!($(COND:THISgrep ->=$(ac)))){
		P $4aisc_server_error = "$(CONDE|Condition error in $(f)$(KEY))";
		P $4return 0;}
	ENDIF
RETURN
# ***************************** create vterms *******************************
FUNCTION create_vterms
	P $(conds_init)$\
RETURN

FUNCTION create_index flag,return
	IF $(index) !~ #
		P $3int index;
	ENDIF
	IF $(flag) = y
		IF $(conds) ~ &
				P $3if(!($(conds:#&&=))){$\
				P return $(INIT|0); }
		ENDIF
	ENDIF
	IF $(index) !~ #
		P $3index = aisc_talking_get_index(0,$(index));
		IF $(return) = n
			P $3if (aisc_server_error) return ;
		ELSE
			P $3if (aisc_server_error) return $(return);
		ENDIF
	ENDIF
RETURN

# ***************************** create access including testing *******************************
FUNCTION create_access
	CREATE $(c) $(conds)
	IF $(c) ~ &
			P $3if(!($(c:#&&=))){$\
			P return $(INIT|0); }
	ENDIF
RETURN


# ***************************** create  testing *******************************
FUNCTION create_access_noval
	CREATE $(c) $(conds)
				IF $(c:&=-) = $(c)
					# Keine Abfragen noetig
				ELSE
					P $3if(!($(c:#&&=))){ return ; }
				ENDIF
RETURN

# ***************************** create  output *******************************
FUNCTION print_tabs
		P #define static
		P static void * aisc_talking_functions_set_$(STRUCT)[] = {
		FOR $(i) = 0 TO $(MAX_KEY)
			P $1(void *)$(set_list[$(i)])/*$(i)*/
		ENDFOR
		P $10$n};$n
		P static void *aisc_talking_functions_get_$(STRUCT)[] = {
		FOR $(i) = 0 TO $(MAX_KEY)
			P $1(void *)$(get_list[$(i)])
		ENDFOR
		P $10$n};$n
		P static void * aisc_talking_functions_create_$(STRUCT)[]= {
		FOR $(i) = 0 TO $(MAX_KEY)
			P $1(void *)$(create_list[$(i)])
		ENDFOR
		P $10$n};$n
		P static void * aisc_talking_functions_find_$(STRUCT)[] = {
		FOR $(i) = 0 TO $(MAX_KEY)
			P $1(void *)$(find_list[$(i)])
		ENDFOR
		P $10$n};$n
		P static void * aisc_talking_functions_copy_$(STRUCT)[] = {
		FOR $(i) = 0 TO $(MAX_KEY)
			P $1(void *)$(copy_list[$(i)])
		ENDFOR
		P $10$n};$n
RETURN

