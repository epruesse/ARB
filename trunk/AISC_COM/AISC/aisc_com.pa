
IF $(argc) = 4
ELSE
	ERROR	Falsche Parameteranzahl: Syntax aisc xxx.pa xxx.aisc outfile
ENDIF

DATA AISC { $(#FILE $(argv[2])) };
OPEN save $(argv[3])
MOVETO $(AISC/PROJECT)

IF $(MYTABSTOP)
	TABSTOP $(MYTABSTOP)
ELSE
	TABSTOP 8
ENDIF	
TAB	0	0
TAB	1	8
TAB	2	16
TAB	3	24
TAB	4	32
TAB	5	40
TAB	6	48
TAB	7	56
TAB	8	64
TAB	9	70

OUT save
MOVETO $(DATA/.)

P /*********************************************************************
P  * Created automagically from $(argv[2])
P  * using aisc-script 'aisc_com.pa'
P  * DO NOT EDIT THIS FILE!!!
P  *********************************************************************/$n

P #ifndef AISC_MAX_OBJECT
P #define AISC_MAX_OBJECT $(MAX_OBJECT)
P #define AISC_MAX_ATTR $(MAX_KEY)
P #define MAX_AISC_SET_GET $(MAX_PAR_CNT)
P #define AISC_MAX_STRING_LEN $(MAX_STRING_LEN)
P #define AISC_MESSAGE_BUFFER_LEN ((AISC_MAX_STRING_LEN/4+3)*($(MAX_PAR_CNT)+2))
P #define AISC_MAGIC_NUMBER $(MAGIC_NUMBER)00

P $ntypedef struct struct_aisc_com {
P $1int$2socket;
P $1int$2message_type;
P $1char$2*message;
P $1int$2*message_queue;
P $1int$2magic;
P $1char$2*error;$n} aisc_com;

P #ifndef _AISC_BYTESTRING
P #define _AISC_BYTESTRING
P $ntypedef struct struct_bytestring {
P $1char$2*data;
P $1int$2size;$n} bytestring;
P #endif


P #ifdef __cplusplus
P const int $1AISC_GET$3= (int)AISC_MAGIC_NUMBER$6+ 0;
P const int $1AISC_SET$3= (int)AISC_MAGIC_NUMBER$6+ 1;
P const int $1AISC_NSET$3= (int)AISC_MAGIC_NUMBER$6+ 2;
P const int $1AISC_CREATE$3= (int)AISC_MAGIC_NUMBER$6+ 3;
P const int $1AISC_FIND$3= (int)AISC_MAGIC_NUMBER$6+ 4;
P const int $1AISC_COPY$3= (int)AISC_MAGIC_NUMBER$6+ 5;
P const int $1AISC_DELETE$3= (int)AISC_MAGIC_NUMBER$6+ 6;
P const int $1AISC_INIT$3= (int)AISC_MAGIC_NUMBER$6+ 7;
P const int $1AISC_DEBUG_INFO$3= (int)AISC_MAGIC_NUMBER$6+ 8;
P #else
P $nenum aisc_command_list {
P $1AISC_GET$3= AISC_MAGIC_NUMBER$6+ 0,
P $1AISC_SET$3= AISC_MAGIC_NUMBER$6+ 1,
P $1AISC_NSET$3= AISC_MAGIC_NUMBER$6+ 2,
P $1AISC_CREATE$3= AISC_MAGIC_NUMBER$6+ 3,
P $1AISC_FIND$3= AISC_MAGIC_NUMBER$6+ 4,
P $1AISC_COPY$3= AISC_MAGIC_NUMBER$6+ 5,
P $1AISC_DELETE$3= AISC_MAGIC_NUMBER$6+ 6,
P $1AISC_INIT$3= AISC_MAGIC_NUMBER$6+ 7,
P $1AISC_DEBUG_INFO$3= AISC_MAGIC_NUMBER$6+ 8,
P 	};
P #endif

P #ifdef __cplusplus
P 	const int $1AISC_CCOM_OK$3= AISC_MAGIC_NUMBER$6+ 0;
P 	const int $1AISC_CCOM_ERROR$3= AISC_MAGIC_NUMBER$6+ 1;
P 	const int $1AISC_CCOM_MESSAGE$3= AISC_MAGIC_NUMBER$6+ 2;
P #else
P 	$nenum aisc_client_command_list {
P 		AISC_CCOM_OK$3= AISC_MAGIC_NUMBER$6+ 0,
P 		AISC_CCOM_ERROR$3= AISC_MAGIC_NUMBER$6+ 1,
P 		AISC_CCOM_MESSAGE$3= AISC_MAGIC_NUMBER$6+ 2,
P 	};
P #endif
P #endif

FOR $(ENUM)
	IF $(SKEY)
		CREATE $(my_attribute[$(ENUM)]) $(OBJECT_KEY)_ATTR_$(SKEY)
	ENDIF
#	P	typedef enum enum_$(ENUM) {
#	FOR $({/VAR)
#		IF $(VAL)
#			P $2$(VAR)$3=$4 $(VAL),$\
#		ELSE
#			P $2$(VAR),$\
#		ENDIF
#		P $6/* $(DOCU)$8*/
#	ENDFOR
#	P	} $(ENUM);
ENDFOR
P $n


FOR $(STRUCT)
	IF $(JOINED)
	ELSEIF $(SKEY)
		P typedef long T_$(OBJECT_KEY)_$(SKEY);
	ENDIF
ENDFOR
P $n$n
P #define $(OBJECT_KEY)_ATTR_INT(a,b)$6( (a+b) | 0x1000000 )
FOR $(ENUM)
	IF $(SKEY)
		P #define $(OBJECT_KEY)_ATTR_$(SKEY)(a,b)$6( (a+b) | 0x1000000 )
	ENDIF
ENDFOR

P #define $(OBJECT_KEY)_ATTR_DOUBLE(a,b)$6( (a+b) | 0x2000000 )
P #define $(OBJECT_KEY)_ATTR_STRING(a,b)$6( (a+b) | 0x3000000 )
CREATE $(my_attribute[char]) $(OBJECT_KEY)_ATTR_INT
CREATE $(my_attribute[int]) $(OBJECT_KEY)_ATTR_INT
CREATE $(my_attribute[func]) $(OBJECT_KEY)_ATTR_INT
CREATE $(my_attribute[t_key]) $(OBJECT_KEY)_ATTR_INT
CREATE $(my_attribute[dllheader_ext]) $(OBJECT_KEY)_ATTR_INT
CREATE $(my_attribute[double]) $(OBJECT_KEY)_ATTR_DOUBLE
CREATE $(my_attribute[aisc_string]) $(OBJECT_KEY)_ATTR_STRING
CREATE $(my_attribute[bytestring]) $(OBJECT_KEY)_ATTR_BYTES
FOR $(STRUCT)
	IF $(JOINED)
	ELSEIF $(SKEY)
		P #define $(OBJECT_KEY)_ATTR_$(SKEY)(a,b)$6( (a+b) | 0x4000000 )
		CREATE $(my_attribute[$(STRUCT)]) $(OBJECT_KEY)_ATTR_$(SKEY)
	ENDIF
ENDFOR
P #define $(OBJECT_KEY)_ATTR_BYTES(a,b)$6( (a+b) | 0x5000000 )

P $n$ntypedef enum Attributes_Header_List {
FOR $(STRUCT)
	IF $(JOINED)
	ELSEIF $(SKEY)
		P $1$(OBJECT_KEY)_$(SKEY)$5=$6$(SKEYC)*0x10000,
	ENDIF
ENDFOR
P	$1$(OBJECT_KEY)_MAX$5=$6$(MAX_OBJECT)*0x10000,
P	$1$(OBJECT_KEY)_INDEX$5=$60x1ff0000
P	} Aisc_Objekt_Type;$n$n

CREATE $(A)
CREATE $(add) 0
CREATE $(str) 0
CREATE $(skey) 0
CREATE $(struct) 0
CREATE $(com)
	FOR $(STRUCT)
		IF $(SKEY)
			PUSH
			IF $(JOINED)
			ELSE
				P	/************$2$(SKEY)$4*************/
				P	typedef enum {
			ENDIF
			SET $(skey) $(SKEY)
			SET $(struct) $(STRUCT)
			CALL struct_attr,0,$1$(SKEY)_,/* 
			IF $(JOIN_NEXT)
			ELSE
				P $1$(SKEY)_LASTATTR$4= 0
				P } $(OBJECT_KEY)_$(SKEY)_Attribute;$n
			ENDIF
			POP
		ENDIF
	ENDFOR
CLOSE save

EXIT

FUNCTION struct_attr,a,s,c
	FOR $({/TYPE)
		IF $(KEY)
			IF $(TYPE) = dllh
				P $(s)PRED$4= $\
 				P $(my_attribute[$(struct)])$\
				P $6($(OBJECT_KEY)_$(skey),$8$(+ $(a)+$(KEYC))),$9/* DO */
				P $(s)NEXT$4= $\
 				P $(my_attribute[$(struct)])$\
				P $6($(OBJECT_KEY)_$(skey),$8$(+ 1+$(+ $(a)+$(KEYC)))),$9$(c) */

				SET $(add) $(+ $(a)+$(KEYC))
				SET $(add) $(+ 2+$(add))
				SET $(str) $(s)$(KEY)
				PUSH
				MOVETO $(/AISC/DATA/STRUCT.dll_header)
				CALL struct_attr,$(add),$(str),$(c) H
				POP

			ELSEIF $(REF) ~ s
				SET $(add) $(+ $(a),$(KEYC))
				SET $(str) $(s)$(KEY)
				SET $(com) $(c) S
				PUSH
				MOVETO $(/AISC/DATA/STRUCT.$(TYPE))
				CALL struct_attr,$(add),$(str),$(com)
				POP
			ELSE
				IF $(REF) ~ d
					SET $(com) $(c) DL
				ELSEIF $(REF) ~ v
					SET $(com) $(c) [$(SIZE)]
				ELSEIF $(REF) ~ *
					SET $(com) $(c) []
				ELSEIF $(TYPE) = func
					SET $(com) $(c) FUNC
				ELSE
					SET $(com) $(c)
				ENDIF
				IF $(my_attribute[$(TYPE)])
					P $(s)$(KEY)$4= $\
 					P $(my_attribute[$(TYPE)])$\
					P $6($(OBJECT_KEY)_$(skey),$8$(+ $(a)+$(KEYC))),$9$(com) */
				ELSE
					ERROR TYPE $(TYPE) unknown, no key build
				ENDIF
				IF $(REF) ~ d
					P $(s)$(KEY)_CNT$4= $\
 					P $(my_attribute[int])$\
					P $6($(OBJECT_KEY)_$(skey),$8$(+ 1,$(+ $(a)+$(KEYC)))),$9$(com) */
				ENDIF
			ENDIF
		ENDIF
	ENDFOR
RETURN
