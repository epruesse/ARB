// ================================================================ //
//                                                                  //
//   File      : ut_valgrinded.h                                    //
//   Purpose   : wrapper to call subprocesses inside valgrind       //
//                                                                  //
//   Coded by Ralf Westram (coder@reallysoft.de) in February 2011   //
//   Institute of Microbiology (Technical University Munich)        //
//   http://www.arb-home.de/                                        //
//                                                                  //
// ================================================================ //

#ifndef UT_VALGRINDED_H
#define UT_VALGRINDED_H


#ifdef UNIT_TESTS

#ifndef ARB_MSG_H
#include <arb_msg.h>
#endif
#ifndef _SYS_STAT_H
#include <sys/stat.h>
#endif


#define UTVG_ANY_SYSCALL "any.syscall"

namespace utvg {

    inline const char *flag_name(const char *name) {
        const char *ARBHOME = getenv("ARBHOME");
        const int   BUFSIZE = 200;
        static char buf[BUFSIZE];

        int printed = snprintf(buf, BUFSIZE, "%s/UNIT_TESTER/valgrind/%s", ARBHOME, name);
        arb_assert(printed<BUFSIZE);

        return buf;
    }
    inline bool flag_exists(const char *name) {
        const char  *path = flag_name(name);
        struct stat  stt;
        
        return stat(path, &stt) == 0 && S_ISREG(stt.st_mode);
    }

    struct valgrind_info {
        bool wanted;
        bool leaks;
        bool reachable;

        valgrind_info() {
            // The following flag files are generated by ../UNIT_TESTER/Makefile.suite
            // which reads the settings from ../UNIT_TESTER/Makefile.setup
            wanted    = flag_exists("flag.valgrind");
            leaks     = flag_exists("flag.valgrind.leaks");
            reachable = flag_exists("flag.valgrind.reachable");
        }
    };

    inline void touch(const char *file) {
        FILE *out = fopen(file, "w");
        fclose(out);
    }
};

inline void make_valgrinded_call(char *&command) {
    using namespace utvg;
    static valgrind_info valgrind;
    if (valgrind.wanted) {
// #define VALGRIND_ONLY_SOME
#if defined(VALGRIND_ONLY_SOME)
        bool perform_valgrind = false;

        perform_valgrind = perform_valgrind || strstr(command, "arb_pt_server");
        perform_valgrind = perform_valgrind || strstr(command, "arb_primer");

        if (!perform_valgrind) return;
#endif

        const char *switches           = valgrind.leaks ? (valgrind.reachable ? "-l -r" : "-l") : "";
        char       *valgrinded_command = GBS_global_string_copy("$ARBHOME/UNIT_TESTER/valgrind/arb_valgrind_logged CALL %s -c 15 %s", switches, command);
        freeset(command, valgrinded_command);

        touch(flag_name(UTVG_ANY_SYSCALL));
    }
}

#else

#define make_valgrinded_call(command)

#endif


#else
#error ut_valgrinded.h included twice
#endif // UT_VALGRINDED_H
