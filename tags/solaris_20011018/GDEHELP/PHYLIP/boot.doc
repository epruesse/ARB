
                                                                    version 3.4


        BOOT - Bootstrap confidence intervals on mixed method parsimony


(c)  Copyright  1986-1991  by  the  University  of  Washington  and  by  Joseph
Felsenstein.   Written  by  Joseph  Felsenstein.  Permission is granted to copy
this document provided that no fee is charged for it and  that  this  copyright
notice is not removed.

     BOOT implements the bootstrap  method  of  placing  confidence  limits  on
phylogenies,   using   mixed  method  parsimony.   The  bootstrap  approach  to
phylogenies is described in a  paper  of  mine  in  the  July,  1985  issue  of
Evolution  (Felsenstein,  1985b).  You should read that paper before using this
program.

     The bootstrap method samples  from  your  data,  drawing  characters  with
replacement,  to  create a new data table.  This is then analyzed, and a record
kept of all groups of species that form monophyletic subsets in  the  resulting
estimated  phylogeny.   The  process  of  resampling  and  estimating  is  then
repeated, and this is continued many times (at least 20  seems  necessary,  but
more  is  desireable).   If  you are interested in whether there is significant
evidence for the monophyly of some group, then you are to consider the evidence
significant  if  it  occurs in at least 95% of the bootstrap estimates.  If the
groups in which you are interested are chosen after seeing the results, then  a
more  conservative  rule  is necessary, such as considering a group significant
only if it occurs in at least 100 - 5/(n-1) percent of the bootstrap estimates,
where n is the number of species.

     This program contains a random number generator  and  uses  that  to  draw
bootstrap  samples of the data.  Each of these is analyzed and the monophyletic
groups in the resulting tree recorded.  At the end a table of these groups  and
their frequencies is printed out.

     Although the data is in the usual form of binary characters, you may  wish
to  bootstrap by sampling from the original multistate characters.  An option F
(for Factors) is provided to inform the bootstrap sampling process which groups
of  binary  characters  are  translated from the same multistate character, and
thus should be kept together during the sampling  process.   The  F  option  is
described below.

     The program can be fairly slow to run: the algorithm is the  one  used  in
MIX,  and  if  50  bootstrap  samples  are  drawn  the program will take almost
precisely 50 times as long as a single MIX  run.   If  you  do  not  have  free
computer  time you may want to be careful about running this program.  Although
with MIX I counsel multiple runs with different  input  orders  of  species  to
increase  the chance of finding a most parsimonious tree, I would not recommend
that for this program.  In my experience the variability of trees obtained from
the  different  bootstrap samples is so great that the much smaller increase in
precision resulting from multiple runs on each of those bootstrap sampled  data
sets  is  not  worth  the extra run time.  The program as presently constructed
runs only once for each bootstrap data set.  However each run  involves  global
branch swapping and can find multiple, equally parsimonious trees.  It would be
possible to instead use an algorithm such as  that  of  PENNY  to  be  sure  of
finding  the  most parsimonious tree for each bootstrap sampled data set, but I
am fairly sure that this would simply result in a great waste of computer time,
as  most  of  the breadth of the confidence interval comes from the variability
resulting from the bootstrap sampling process, not the fairly to find the  most
parsimonious trees.


     It is possible to essentially duplicate the functions of BOOT by using the
sequence  of  programs SEQBOOT --> MIX --> CONSENSE.  By using PENNY instead of
MIX in this sequence on could do a bootstrap study using exact branch-and-bound
solutions.


                                  ASSUMPTIONS

     The parsimony methods used are precisely those available in MIX, and  thus
the  biological  assumptions are the same as in that program.  MIX is a general
parsimony program which  carries  out  the  Wagner  and  Camin-Sokal  parsimony
methods  in  mixture,  where each character can have its method specified.  The
program defaults to carrying out Wagner parsimony.

     The Camin-Sokal parsimony  method  explains  the  data  by  assuming  that
changes  0  --> 1 are allowed but not changes 1 --> 0.  Wagner parsimony allows
both kinds of changes.  (This under the assumption  that  0  is  the  ancestral
state,  though the program allows reassignment of the ancestral state, in which
case we must reverse the state numbers 0 and  1  throughout  this  discussion).
The criterion is to find the tree which requires the minimum number of changes.
The Camin-Sokal method is due to Camin and Sokal (1965) and the  Wagner  method
to Eck and Dayhoff (1966) and to Kluge and Farris (1969).

     Here are the assumptions of these two methods:

     1. Ancestral states are known (Camin-Sokal) or unknown (Wagner).

     2. Different characters evolve independently.

     3. Different lineages evolve independently.

     4. Changes 0 --> 1 are much more probable than changes  1  -->  0  (Camin-
Sokal) or equally probable (Wagner).

     5. Both of these kinds  of  changes  are  a  priori  improbable  over  the
evolutionary  time  spans  involved  in  the  differentiation  of  the group in
question.

     6. Other kinds of evolutionary event such as retention of polymorphism are
far less probable than 0 --> 1 changes.

     7. Rates of evolution in different lineages are sufficiently low that  two
changes  in a long segment of the tree are far less probable than one change in
a short segment.

     That these are the assumptions of parsimony methods has been documented in
a  series of papers of mine: (1973a, 1978b, 1979, 1981b, 1983b, 1988b).  For an
opposing  view  arguing  that  the  parsimony  methods  make   no   substantive
assumptions  such  as  these, see the papers by Farris (1983) and Sober (1983a,
1983b), but also read the exchange between Felsenstein and Sober (1986).


                               INPUT AND OUTPUT

     The input for BOOT is largely identical to the standard input for discrete
characters  programs,  described  above  in  the  documentation  file  for  the
discrete-characters programs.  In  the  data  states  "?",  "P",  and  "B"  are
allowed.

     The program starts by asking the user to supply a random number seed.  The
random  number  seed should be an odd number which leaves a remainder of 1 when


divided by 4, so that it is of the form 4n+1 (for example 241 is of  this  form
but 255 is not).

     The options are mostly selected using a menu:


Bootstrapped mixed parsimony algorithm, version 3.4

Settings for this run:
  J   Bootstrap or delete-half Jackknife?  Bootstrap
  R                  How many replicates?  100
  X                     Use Mixed method?  No
  P                     Parsimony method?  Wagner
  O                        Outgroup root?  No, use as outgroup species  1
  T              Use Threshold parsimony?  No, use ordinary parsimony
  A   Use ancestral states in input file?  No
  L       Global or local rearrangements?  Global
  0   Terminal type (IBM PC, VT52, ANSI)?  IBM PC
  1    Print out the data at start of run  No
  2  Print indications of progress of run  Yes
  3   Write individual trees to tree file  No
  4                        Print out tree  Yes
  5       Write out trees onto tree file?  Yes

Are these settings correct? (type Y or the letter for one to change)

The options X, O, T, and A are the usual Mixed  Methods,  Outgroup,  Threshold,
and  Ancestor  options,  described  in  the  main  documentation file or in the
Discrete Characters Programs documentation files.  The O option is  acted  upon
only  if  the final tree is unrooted.  Note that when any of the characters has
Camin-Sokal parsimony assumed for it, the tree is rooted and the O option  will
have  no effect.  If the A option is invoked, the ancestor is not to be counted
as one of the species.  If the A option is not  used,  then  the  program  will
assume  0 as the ancestral state for those characters following the Camin-Sokal
method, and  will  assume  that  the  ancestral  state  is  unknown  for  those
characters  following  Wagner parsimony.  You will find it useful to understand
the  difference  between  the  Camin-Sokal  parsimony  criterion  with  unknown
ancestral state and the Wagner parsimony criterion.

     The T (Threshold) option allows a continuum of methods  between  parsimony
and  compatibility.   Thresholds  less  than  or  equal  to 1.0 do not have any
meaning and should not be used: they will result in a tree  dependent  only  on
the input order of species and not at all on the data!

     Option R selects the number of bootstrap or  jackknife  replicates  to  be
run.   It  defaults to 100 but the larger a number of replicates you can afford
to run, the better.

     Options P toggles between the  Camin-Sokal  parsimony  criterion  and  the
default Wagner parsimony criterion.

     The J option toggles between the default Bootstrap method and the  Delete-
Half  Jackknife  method.   If  the  latter  is  invoked, the random sampling of
characters will not follow the bootstrap pattern, in which the same  number  of
characters  is  drawn,  sampling  with replacement.  Instead half the number of
characters will be drawn, sampling  without  replacement  (in  other  words,  a
random  half  of  the  characters  will  be  drawn).   This should give results
comparable to the bootstrap, and is  included  partly  for  people  who  prefer
jackknifes to bootstraps.



     The  L  (Local)  option  allows  the  user  to  specify  that  only  local
rearrangements  of the tree will be used in searching for the most parsimonious
tree.  This can speed up the program by about a factor of three, but means that
the confidence intervals will be less accurate.

     The 3 (Write out all trees) option is included  for  people  who  want  to
summarize the results of the bootstrapping in different ways.  It causes all of
the bootstrap estimate trees to be written out to the tree  file  The  majority
rule  consensus  tree will also be written out at the end of that file if the Y
option is also used.  If we use (say) 50 replicates of bootstrapping we may see
more  than  50 trees on the output file.  This is because there may be ties for
most parsimonious tree, and all  tied  trees  are  saved.   To  help  the  user
evaluate  the  ties,  the  program prints out at the end of each tied tree what
fraction it is of all trees found in that bootstrap replicate.  Thus if 3 trees
are  found  they  all have weight 0.3333, and that is written out at the end of
the tree, after its final semicolon.  Using the file of  individual  trees  you
may  be  able  to  carry  out  other kinds of analyses of the results of making
bootstrap estimates.

     In the input file the W (Weights) and F (Factors) options  are  available,
as  usual.   The A (Ancestral states) and X (Mixed methods) choices in the menu
also requires the options to be declared in the first line of  the  input  file
and other information to be present in the input file.  If the Ancestral States
option is invoked then you must also choose the A option from the  menu.   Note
that  the  X  option  requires  that the option M (Mixture) be declared and the
mixture information provided in the input file.  This is admittedly confusing.

     If the F option is invoked then the bootstrap sampling of characters will,
in  the  above  example, sample 9 characters with replacement from 9 multistate
characters.  The first four binary characters will thus always be  sampled  the
same number of times, as will the next three, and so on.

     The Weights  option  is  the  usual  one.   Bootstrapping  or  Delete-Half
Jackknifing  will  take  place  only  among  the  characters  that have nonzero
weights, and the number  of  characters  drawn  will  reflect  this  number  of
characters with nonzero weights.

     The program will print, up to 20 times during the run,  a  line  informing
you  of  how  many replicates have been completed.  This is included so that in
the event that you run into a system time limit you  will  at  least  know  how
close  you were to finishing, and thus whether there is any point in increasing
the time limit and trying again.   It  is  also  meant  to  reassure  you  that
something is, in fact, happening.

     An important part of the output is a table showing the monophyletic groups
that  were  found,  and  the  number  of times they were found, in order of the
number of times they were found.  Only those groups that  are  compatible  with
the ones found most frequently are shown, because only those have any chance to
be significant (all groups that appear more than 50% of the time will be  shown
in  any case).  The groups are printed out in a straightforward fashion.  There
is one line for  each  monophyletic  group.   On  that  line  is  a  string  of
characters,  "*"  or ".", indicating respectively whether each species is ("*")
or is not (".") present in the group.  The species are in the  order  in  which
they appear in the input data.  Next on the line is the count of how many times
this group appeared.  Thus, if the species are A, B, C, D, and E and are  input
in that order, if the group (B, D, E) shows up in 36 of the bootstrap estimates
there should be a line that reads:

 .*.**                   36

in the table.  If a number of equally most parsimonious trees (say 5  of  them)


were  found and the group appeared in only one of the these, this is counted as
1/5 of an appearance.  The majority-rule consensus tree could be  reconstructed
from  the  table  simply by taking all the groups that appear a majority of the
time.

     Fortunately, the next part of  the  output  consists  of  a  tree  diagram
showing  the  majority rule consensus tree.   At each internal node of the tree
is printed the number of times the group above and to the right of that node is
found.  Thus if there are 100 replicates the tree:

           +--Epsilon
        +-50
     +-42  +--Delta
     !  !
  +100  +-----Gamma
  !  !
--*  +--------Beta
  !
  +-----------Alpha

  remember: this is an unrooted tree!

shows that group (Delta, Epsilon) occurred 50  times  out  of  100  replicates,
group (Gamma, Delta, Epsilon) 42 times, and group (Beta, Gamma, Delta, Epsilon)
all 100 times.  Of course, the last of these is not surprising since  the  tree
is unrooted and thus any group in it that contains all but one species is bound
to occur every time.

     If you want also to see all the groups  that  were  found  that  were  not
compatible with the most frequently-occurring groups, you could choose option 3
(Write out individual trees to tree file) and turn off option 5.  The resulting
tree  file  will have the individual replicate trees.  Using CONSENSE one could
make a consensus tree of these, which should be identical to the tree that this
program  prints out.  But the CONSENSE output will also show a table of all the
groups that were found in any of the tree but not  included  in  the  consensus
tree.

     Note that if the  trees  inferred  are  unrooted,  the  monophyly  of  the
resulting  groups  is  suspect  to  that extent.  Thus in an unrooted tree with
species A, B, C, D, and E if one sees the group (B,  D,  E)  what  that  really
means  is  that either (A, C) or (B, D, E) is monophyletic, and you do not know
which without some rooting information.

     I must confess that  there  is  one  possible  problem  with  the  current
program,  although  it is not one that will affect many users.  If you put in a
data set that has ancestral states specified for some, but not  all  characters
in  a  Wagner  parsimony  analysis,  then  in the bootstrap sampling it is just
possible that some of the bootstrap samples will lack all the  characters  that
provide  us  with  a  rooting  of  the  tree.   The  resulting groups will then
sometimes be  monophyletic  ones,  and  sometimes  their  complements  will  be
monophyletic.   Thus  if we have rooting information, and frequently find group
(B, D, E), but in some bootstrap samples we lack the  rooting  information  and
find instead (A, C) we may see both listed as monophyletic groups in the output
and not realize that the latter is really conveying the same information as the
former.   I  hope that you do not run into this problem; in a future version of
the program I hope to correct this.

     If the option 5 (Write out trees onto tree file) is used, the result  will
be  written out in parenthesis form as a computer-readable tree.  The tree will
be a bifurcating one, and after each group will be a number indicating how many
times  it  was found, so that if (A,B) occurs 35 times out of 50 replicates the


tree will contain "(A:50,B:50):35".  If the 3 (Write individual trees  to  tree
file)  option  is  in  effect,  then  this tree will be written after all those
individual replicate trees.

     At the beginning of the program are a series of CONSTants,  which  can  be
changed  to help adapt the program to different computer systems.  The CONSTant
maxsp is the maximum number of species allowed.  maxsz  is  related  to  maxsp.
The  maximum  number  of  characters is given by maxchr, and bits indicates the
maximum size of a Pascal SET.  wrds  is  derived  from  maxchr  and  bits,  and
nmlngth is the length of the species names.

     You may want to change these constants to speed up program  execution  and
reduce  memory  requirements,  particularly  by making bits larger if possible.
Because the current program is a bit crude, it does not not allow a  number  of
species  larger  than  the  Pascal set size given by the CONStant "bits".  This
should not be a limitation unless your Pascal only  allows  small  sets.   Note
that  if your Pascal allows sets as large as (say) 255 elements, and you forget
to raise bits to 255 but leave it at the default value of 30,  you  cannot  run
cases larger than 30 species.

     The CONStant maxgrp gives the maximum  number  of  different  monophyletic
groups  that can be found.  It is initialized to 1000 in the distribution copy.
This should be plenty, but in case you find that you  need  to  change  it  you
should  be  safe if you set it to a value about twice the product of the number
of species and the number of replicates to be run.  In most cases you should be
able  to  get away with smaller values of maxgrp than that without encountering
the "hash table overflow" error  message.   If  you  do  encounter  that  error
message you should increase maxgrp.

     The program is a descendant of MIX, and runs at the same speed as MIX  for
each replicate.

-------------------------------TEST DATA SET----------------------------

     5    6
Alpha     110110
Beta      110000
Gamma     100110
Delta     001001
Epsilon   001110

--------------- TEST SET OUTPUT (with random number seed 3133) ----------------

Bootstrapped mixed parsimony algorithm, version 3.4

Wagner parsimony method



Set (species in order)     How many times out of 100

*....                          100.00

The numbers at the forks indicate the number
of times the group consisting of the species
to the right of that fork occurred among the
 100 bootstrap replicates



           +--Epsilon


        +-50
     +-42  +--Delta
     !  !
  +100  +-----Gamma
  !  !
--*  +--------Beta
  !
  +-----------Alpha

  remember: this is an unrooted tree!



















































